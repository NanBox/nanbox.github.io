<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[浪起来！使用 drawBitmapMesh 实现仿真水波纹效果]]></title>
      <url>%2F2017%2F04%2F22%2F201704221946%2F</url>
      <content type="text"><![CDATA[在 Android 的画布 Canvas 里面有个 drawBitmapMesh 方法，通过它可以实现对 Bitmap 的各种扭曲。我们试一下用它把图像扭出水波纹的效果。 和 Material Design 里扁平化的水波纹不同，这里是通过对图像的处理，模拟真实的水波纹效果，最后实现的效果如下： drawBitmapMesh 简介我们先了解一下「网格」的概念。 将一个图片横向、纵向均匀切割成 n 份，就会形成一个「网格」，我把所有网格线的交点称为「顶点」。 正常情况下，顶点是均匀分布的。当我们改变了顶点的位置时，系统会拿偏移后的顶点坐标，和原来的坐标进行对比，通过一套算法，将图片进行扭曲，像这样： 接下来看看 drawBitmapMesh 方法： 12345678public void drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint) 它的参数如下： bitmap - 需要转换的位图 meshWidth - 横向的格数，需大于 0 meshHeight - 纵向的格数，需大于 0 verts - 网格顶点坐标数组，记录扭曲后图片各顶点的坐标，数组大小为 (meshWidth+1) (meshHeight+1) 2 + vertOffset vertOffset - 从第几个顶点开始对位图进行扭曲，通常传 0 colors - 设置网格顶点的颜色，该颜色会和位图对应像素的颜色叠加，数组大小为 (meshWidth+1) * (meshHeight+1) + colorOffset，可以传 null colorOffset - 从第几个顶点开始转换颜色，通常传 0 paint - 「画笔」，可以传 null 需要说明一下的是，可以用 colors 这个参数来实现阴影的效果，但在 API 18 以下开启了硬件加速，colors 这个参数是不起作用的。我们这里只关注前面四个参数，后面四个传 0、null、0、null 就可以了。 创建 RippleLayout创建自定义控件 RippleLayout，为了让控件用起来更灵活，我让它继承了 FrameLayout（套上哪个哪个浪！）。 定义了如下成员变量： 12345678910111213141516171819//图片横向、纵向的格数private final int MESH_WIDTH = 20;private final int MESH_HEIGHT = 20;//图片的顶点数private final int VERTS_COUNT = (MESH_WIDTH + 1) * (MESH_HEIGHT + 1);//原坐标数组private final float[] staticVerts = new float[VERTS_COUNT * 2];//转换后的坐标数组private final float[] targetVerts = new float[VERTS_COUNT * 2];//当前控件的图片private Bitmap bitmap;//水波宽度的一半private float rippleWidth = 100f;//水波扩散速度private float rippleSpeed = 15f;//水波半径private float rippleRadius;//水波动画是否执行中private boolean isRippling; 看注释就知道什么意思啦，下面会用到的。 然后又定义了一个这里会经常用到的方法，根据宽高计算对角线的距离（勾股定理）： 12345678910/** * 根据宽高，获取对角线距离 * * @param width 宽 * @param height 高 * @return 距离 */private float getLength(float width, float height) &#123; return (float) Math.sqrt(width * width + height * height);&#125; 获取 Bitmap要处理 Bitmap，第一步当然是先拿到 Bitmap，拿到后就可以根据 Bitmap 的宽高初始化两个顶点坐标数组： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 初始化 Bitmap 及对应数组 */private void initData() &#123; bitmap = getCacheBitmapFromView(this); if (bitmap == null) &#123; return; &#125; float bitmapWidth = bitmap.getWidth(); float bitmapHeight = bitmap.getHeight(); int index = 0; for (int height = 0; height &lt;= MESH_HEIGHT; height++) &#123; float y = bitmapHeight * height / MESH_HEIGHT; for (int width = 0; width &lt;= MESH_WIDTH; width++) &#123; float x = bitmapWidth * width / MESH_WIDTH; staticVerts[index * 2] = targetVerts[index * 2] = x; staticVerts[index * 2 + 1] = targetVerts[index * 2 + 1] = y; index += 1; &#125; &#125;&#125;/** * 获取 View 的缓存视图 * * @param view 对应的View * @return 对应View的缓存视图 */private Bitmap getCacheBitmapFromView(View view) &#123; view.setDrawingCacheEnabled(true); view.buildDrawingCache(true); final Bitmap drawingCache = view.getDrawingCache(); Bitmap bitmap; if (drawingCache != null) &#123; bitmap = Bitmap.createBitmap(drawingCache); view.setDrawingCacheEnabled(false); &#125; else &#123; bitmap = null; &#125; return bitmap;&#125; 计算偏移坐标接下来是重点了。这里要实现的水波的位置在下图的灰色区域： 我定义了一个 warp 方法，根据手指按下的坐标（原点）来重绘 Bitmap： 1234567891011121314151617181920212223/** * 图片转换 * * @param originX 原点 x 坐标 * @param originY 原点 y 坐标 */private void warp(float originX, float originY) &#123; for (int i = 0; i &lt; VERTS_COUNT * 2; i += 2) &#123; float staticX = staticVerts[i]; float staticY = staticVerts[i + 1]; float length = getLength(staticX - originX, staticY - originY); if (length &gt; rippleRadius - rippleWidth &amp;&amp; length &lt; rippleRadius + rippleWidth) &#123; PointF point = getRipplePoint(originX, originY, staticX, staticY); targetVerts[i] = point.x; targetVerts[i + 1] = point.y; &#125; else &#123; //复原 targetVerts[i] = staticVerts[i]; targetVerts[i + 1] = staticVerts[i + 1]; &#125; &#125; invalidate();&#125; 方法里面遍历了所有的顶点，如果顶点是在水波范围内，则需要对这个顶点进行偏移。 偏移后的坐标计算，思路大概是这样的： 为了让水波有突起的感觉，以水波中间（波峰）为分界线，里面的顶点往里偏移，外面的顶点往外偏移： 至于偏移的距离，我想要实现类似放大镜的效果，离波峰越近的顶点，偏移的距离会越大。离波峰的距离和偏移距离的关系，可以看作一个余弦曲线： 我们来看一下 getRipplePoint 方法，传入的参数是原点的坐标及需要转换的顶点坐标，在它里面做了下面这些处理： 通过反正切函数获取到顶点和原点间的水平角度： 1float angle = (float) Math.atan(Math.abs((staticY - originY) / (staticX - originX))); 通过余弦函数计算顶点的偏移距离： 123float length = getLength(staticX - originX, staticY - originY);float rate = (length - rippleRadius) / rippleWidth;float offset = (float) Math.cos(rate) * 10f; 这里的 10f 是最大偏移距离。 计算出来的偏移距离是直线距离，还需要根据顶点和原点的角度，用余弦、正弦函数将它转换成水平、竖直方向的偏移距离： 12float offsetX = offset * (float) Math.cos(angle);float offsetY = offset * (float) Math.sin(angle); 根据顶点原来的坐标和偏移量就可以得出偏移后的坐标了，至于是加还是减，还要看顶点所在的位置。 getRipplePoint 的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 获取水波的偏移坐标 * * @param originX 原点 x 坐标 * @param originY 原点 y 坐标 * @param staticX 待偏移顶点的原 x 坐标 * @param staticY 待偏移顶点的原 y 坐标 * @return 偏移后坐标 */private PointF getRipplePoint(float originX, float originY, float staticX, float staticY) &#123; float length = getLength(staticX - originX, staticY - originY); //偏移点与原点间的角度 float angle = (float) Math.atan(Math.abs((staticY - originY) / (staticX - originX))); //计算偏移距离 float rate = (length - rippleRadius) / rippleWidth; float offset = (float) Math.cos(rate) * 10f; float offsetX = offset * (float) Math.cos(angle); float offsetY = offset * (float) Math.sin(angle); //计算偏移后的坐标 float targetX; float targetY; if (length &lt; rippleRadius + rippleWidth &amp;&amp; length &gt; rippleRadius) &#123; //波峰外的偏移坐标 if (staticX &gt; originY) &#123; targetX = staticX + offsetX; &#125; else &#123; targetX = staticX - offsetX; &#125; if (staticY &gt; originY) &#123; targetY = staticY + offsetY; &#125; else &#123; targetY = staticY - offsetY; &#125; &#125; else &#123; //波峰内的偏移坐标 if (staticX &gt; originY) &#123; targetX = staticX - offsetX; &#125; else &#123; targetX = staticX + offsetX; &#125; if (staticY &gt; originY) &#123; targetY = staticY - offsetY; &#125; else &#123; targetY = staticY + offsetY; &#125; &#125; return new PointF(targetX, targetY);&#125; 我也不知道这种计算方法是否符合物理规律，反正感觉像那么回事。 执行水波动画大家都知道事件分发机制，作为一个 ViewGroup，会先执行 dispatchTouchEvent 方法。我在事件分发之前执行水波动画，也保证了事件传递不受影响： 123456789@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: showRipple(ev.getX(), ev.getY()); break; &#125; return super.dispatchTouchEvent(ev);&#125; showRipple 的任务就是循环执行 warp 方法，并且不断改变水波半径，达到向外扩散的效果： 123456789101112131415161718192021222324252627282930313233/** * 显示水波动画 * * @param originX 原点 x 坐标 * @param originY 原点 y 坐标 */public void showRipple(final float originX, final float originY) &#123; if (isRippling) &#123; return; &#125; initData(); if (bitmap == null) &#123; return; &#125; isRippling = true; //循环次数，通过控件对角线距离计算，确保水波纹完全消失 int viewLength = (int) getLength(bitmap.getWidth(), bitmap.getHeight()); final int count = (int) ((viewLength + rippleWidth) / rippleSpeed); Observable.interval(0, 10, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .take(count + 1) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; rippleRadius = aLong * rippleSpeed; warp(originX, originY); if (aLong == count) &#123; isRippling = false; &#125; &#125; &#125;);&#125; 这里用了 RxJava 2 实现循环，循环的次数是根据控件的对角线计算的，保证水波会完全消失。水波消失后再点击才会执行下一次的水波动画。 注意！要点题了。 讲了这么多还没用到 drawBitmapMesh 方法。ViewGroup 绘制子控件的方法是 dispatchDraw，warp 方法最后调用的 invalidate() 也会触发 dispatchDraw 的执行，所以可以在这里做手脚： 12345678@Overrideprotected void dispatchDraw(Canvas canvas) &#123; if (isRippling &amp;&amp; bitmap != null) &#123; canvas.drawBitmapMesh(bitmap, MESH_WIDTH, MESH_HEIGHT, targetVerts, 0, null, 0, null); &#125; else &#123; super.dispatchDraw(canvas); &#125;&#125; 如果是自定义 View 的话，要修改 onDraw 方法。 到这就完成啦。妥妥的。 对了，不建议用这个控件包裹可滑动或者有动画的控件，因为在绘制水波的时候，子控件的变化都是看不到的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我把 Toolbar 转了一下变成了菜单]]></title>
      <url>%2F2017%2F04%2F13%2F201704132119%2F</url>
      <content type="text"><![CDATA[侧滑菜单我们见的太多了，有没有想过有别的方式弹出菜单？比如，让 Toolbar 变成菜单？ 我也不知道怎么描述这个效果了，直接放效果图吧： 炸不炸！ 其实实现起来超简单。 思路看上去好像 Toolbar 变成了菜单，但大家也能猜到，这里面的旋转菜单其实和 Toolbar 是两个控件，左上角的菜单按钮也是也是两个按钮，只不过在同样的位置放了同样的图片。 所以我自定义了一个旋转控件 SpringRotateMenu，继承 FrameLayout，在这里面实现旋转动画及手势操作。 旋转动画Gif 图可能不明显，菜单展开和收起的时候是会抖一下的，有一种「DUANG」的感觉。是不是有种弹簧的感觉？没错，我用的就是新出的弹簧动画（SpringAnimation）。 关于 SpringAnimation，我之前的这篇会有更详细的介绍： 实现一个带下拉弹簧动画的 ScrollView SpringAnimation 支持平移、缩放、旋转等效果，这次我们用到的是它的旋转效果。 我们先定义展开和收起状态的两个角度： 12private final static int ROTATE_EXPAND = 0;private final static int ROTATE_COLLAPSE = -90; 然后这样来获取旋转弹簧动画： 12expandAnimation = new SpringAnimation(this, SpringAnimation.ROTATION, ROTATE_EXPAND);collapseAnimation = new SpringAnimation(this, SpringAnimation.ROTATION, ROTATE_COLLAPSE); 需要注意的是第三个参数。在平移动画里面，第三个参数是偏移量，而在旋转动画里面代表的是度数。在这里我定义了展开动画（旋转到0°）及收起动画（旋转到 -90°）。 然后提供两个方法来设置展开和收起的按钮： 1234567891011121314151617181920212223/** * 设置展开按钮 */public void setExpandButton(View expandButton) &#123; expandButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; expand(); &#125; &#125;);&#125;/** * 设置折叠按钮 */public void setCollapseButton(View collapseButton) &#123; collapseButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; collapse(); &#125; &#125;);&#125; 展开按钮就是 Toolbar 上的按钮，收起按钮则是菜单上的按钮。 展开、收起的方法也很简单： 123456789101112131415161718192021222324252627282930313233343536373839/** * 展开菜单 */public void expand() &#123; setVisibility(VISIBLE); expandAnimation.start(); if (listener != null) &#123; listener.expandBegin(); collapseAnimation.addEndListener(new DynamicAnimation.OnAnimationEndListener() &#123; @Override public void onAnimationEnd(DynamicAnimation animation, boolean canceled, float value, float velocity) &#123; setVisibility(INVISIBLE); listener.expandEnd(); &#125; &#125;); &#125;&#125;/** * 折叠菜单 */public void collapse() &#123; collapseAnimation.start(); if (listener != null) &#123; listener.collapseBegin(); collapseAnimation.addEndListener(new DynamicAnimation.OnAnimationEndListener() &#123; @Override public void onAnimationEnd(DynamicAnimation animation, boolean canceled, float value, float velocity) &#123; listener.collapseEnd(); &#125; &#125;); &#125;&#125; 其实就是让对应的动画执行，菜单在开始展开的时候显示，在完全收起的时候隐藏。至于这里的 listener 是我加的一个动画监听器，监听两个动画的开始和结束，供外部使用。 手势操作手势操作就是重写 onTouchEvent，代码如下： 1234567891011121314151617181920212223242526272829303132333435private float mDownX;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if (expandAnimation.isRunning() || collapseAnimation.isRunning()) &#123; return super.onTouchEvent(event); &#125; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = event.getRawX(); break; case MotionEvent.ACTION_MOVE: //滑动距离 float deltaX = event.getRawX() - mDownX; //设置角度 float rotation = (deltaX / (screenWidth * 0.8f)) * ROTATE_COLLAPSE; if (rotation &lt;= ROTATE_EXPAND &amp;&amp; rotation &gt;= ROTATE_COLLAPSE) &#123; setRotation(rotation); &#125; else if (rotation &gt; ROTATE_EXPAND) &#123; setRotation(ROTATE_EXPAND); &#125; else if (rotation &lt; ROTATE_COLLAPSE) &#123; setRotation(ROTATE_COLLAPSE); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: if (getRotation() &lt; ROTATE_COLLAPSE / 3) &#123; collapse(); &#125; else &#123; expand(); &#125; break; &#125; return true;&#125; 核心就是将手指的横向滑动距离转换为旋转角度。我的计算方法是，菜单控件的旋转角度，等于横向滑动距离占屏幕宽度的比例，乘以 -90°。至于为什么宽度要乘以 0.8，我是为了让手指在屏幕上滑过 80% 的宽度，就可以将菜单完全收起。 还有就是手指抬起时的处理。我觉得在用户向右滑动菜单时，大部分情况下是希望将菜单收起的，应该让它更容易收起。所以我的做法是，当手指抬起时，菜单竖直的角度超过 30°，就让它执行收起的动画，否则执行展开的动画。 使用布局使用 SpringRotateMenu 作为旋转菜单的根布局，并设置控件的旋转中心点。默认的 Toolbar 高度为 56dp，如果菜单按钮居中显示的话，可以使用： 12android:transformPivotX=&quot;28dp&quot;android:transformPivotY=&quot;28dp&quot; 然后用 FrameLayout 将它覆盖在 Toolbar 上面。 建议让菜单布局的背景颜色和 Toolbar 的颜色一致，并使用同一个菜单图标，菜单图标里面加一个参数： 1android:rotation=&quot;90&quot; 让图标旋转九十度。 代码在代码里面找到我们的 SpringRotateMenu，然后简单的设置一下，比如这样： 123456789101112131415161718192021222324springRotateMenu.setExpandButton(findViewById(R.id.iv_menu));springRotateMenu.setCollapseButton(springRotateMenu.findViewById(R.id.iv_menu));springRotateMenu.setAnimationListener(new SpringRotateMenu.OnAnimationListener() &#123; @Override public void expandBegin() &#123; toolbar.setVisibility(View.INVISIBLE); &#125; @Override public void expandEnd() &#123; &#125; @Override public void collapseBegin() &#123; &#125; @Override public void collapseEnd() &#123; toolbar.setVisibility(View.VISIBLE); &#125;&#125;); 这样就完成啦，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在 Android Studio 上调试数据库 ( SQLite )]]></title>
      <url>%2F2017%2F04%2F02%2F201704021829%2F</url>
      <content type="text"><![CDATA[以前 Eclipse 时代，调试 SQLite 都是将数据库文件导出到电脑，然后再用软件打开查看。现在我们用 Android Studio，有没有更方便的方法呢？ SQLScout安装SQLScout 是一个 Android Studio 的插件，通过点击： Setting —&gt; Plugings —&gt; Browse Repositories 搜索 SQLScout 安装即可。 要是下载不动，可以到这里下载，然后点击 Install plugin from disk 导入。 加载成功安装后重启 Android Studio，会发现右边的侧边栏出现了 SQLite Exporer，展开后点击「+」会出现三个选项： 我们从下往上说吧。 Local SQLite Database如果要调试的数据库已经导出在电脑里了，就选择这一项来加载。 Android (Download Database Locally)通常情况下，我们要调试的数据库是在手机上的，可以用这个功能把数据库提取出来。选择需要调试的设备、项目包名及数据库名就可以了。 Android (Live Device Connection)上面两种方法的缺点很明显，都无法实时更新数据库。 Live Device Connection 是 SQLScout 2.0 新增的功能，和上面的区别是，它可以实时管理、更新数据库。 使用之前需要在在 project 的 build.gradle 里面添加： 12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url 'http://www.idescout.com/maven/repo/' &#125; &#125;&#125; 在 module 的 build.gradle 里面添加： 1compile 'com.idescout.sql:sqlscout-server:2.0' 在启动的 Activity 的 onCreate 方法添加一句代码： 1SqlScoutServer.create(this, getPackageName()); 调试整个界面如下： 它们分别是： 数据库列表：要调试的数据库列表，展开显示数据库中的表，可以右键打开 SQL 编辑器。 SQL 编辑器：输入 SQL 语句的地方，支持自动补全及代码高亮。 数据控制台：用类似 Excel 的格式展示查询的数据，也可以在这里编辑数据。 数据关系图：用于展示表和字段的关系。 是不是很好用，简直就是神器啊！但这么好用的东西是收费的。 穷屌丝用不起怎么办？接着往下看啊。 Android Debug Database这是一个开源的项目（免费），项目地址在这。 先在 module 的 build.gradle 里面添加： 1debugCompile 'com.amitshekhar.android:debug-db:1.0.0' 让手机和电脑处于一个局域网下，当项目跑起来的时候，在 logcat 里面会打印出这么一行： 1D/DebugDB: Open http://XXX.XXX.X.XXX:8080 in your browser 把地址复制到浏览器，就会看到一个这样的界面： 很容易理解，里面几个栏目分别是： Query：写 SQL 语句的地方 Databases：数据库 Tables：数据库中的表 Data：表中的数据，支持编辑、搜索 就是这么简单，妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现一个带下拉弹簧动画的 ScrollView]]></title>
      <url>%2F2017%2F03%2F25%2F201703251208%2F</url>
      <content type="text"><![CDATA[在刚推出的 Support Library 25.3.0 里面新增了一个叫 SpringAnimation 的动画，也就是弹簧动画。要是用它来做一个滑动控件下拉回弹的效果，应该不错吧。 SpringAnimation开始之前，别忘了在 app 的 build.gradle 加上： compile ‘com.android.support:appcompat-v7:25.3.0’compile ‘com.android.support:design:25.3.0’compile ‘com.android.support:support-dynamic-animation:25.3.0’ 然后我们看看 SpringAnimation 的基本用法，首先是它的构造方法： 12345public SpringAnimation(View v, ViewProperty property, float finalPosition) &#123; super(v, property); mSpring = new SpringForce(finalPosition); setSpringThreshold();&#125; 看命名可以大概猜到参数的意义了： v - 要执行动画的控件 property - 动画的性质，可以选择平移、缩放、旋转等 finalPosition - 动画结束时，控件所在位置的坐标偏移量 这里实现的滑动控件是上下滑动的，所以我们这样来获取 SpringAnimation ： 1springAnim = new SpringAnimation(this, SpringAnimation.TRANSLATION_X, 0); SpringAnimation 里面有两个比较重要的属性，分别是： Stiffness - 刚度，值越大回弹的速度越快，类似于劲度系数，默认值是 1500f DampingRatio - 阻尼，值越小，回弹后，动画来回的次数越多，就是更有「DUANG」的感觉，默认值是 0.5f 通过 1springAnim.getSpring().setStiffness(float stiffness) 和1springAnim.getSpring().setDampingRatio(float dampingRatio) 来设置上面两个属性。 再调用 springAnim.start() 就可以开始动画啦。 SpringScrollView我们自定义一个 SpringScrollView 继承 NestedScrollView，重写 onTouchEvent 方法让它有回弹的效果： 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_MOVE: if (getScrollY() &lt;= 0) &#123; //顶部下拉 if (startDragY == 0) &#123; startDragY = e.getRawY(); &#125; if (e.getRawY() - startDragY &gt; 0) &#123; setTranslationY((e.getRawY() - startDragY) / 3); return true; &#125; else &#123; springAnim.cancel(); setTranslationY(0); &#125; &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: if (getTranslationY() != 0) &#123; springAnim.start(); &#125; startDragY = 0; break; &#125; return super.onTouchEvent(e);&#125; 简单解释一下哈。 当 ScrollView 在顶部时，记录下手指所在的 y 轴位置。在顶部并且是往下滑动的时候，给 ScrollView 设置一个纵向的偏移。之所以除以 3，是为了让控件有种要用力才能拖动的感觉。 在顶部的时候如果是往上滑动，则把动画效果取消，把控件位置复原，否则可能出现控件一直偏移的情况。 最后当手指抬起时，执行弹簧动画就好了。 为什么这里用 getRawY() 获取坐标，而不是用 getY() 来获取。因为 getY() 是相对于控件的坐标，当设置了 TranslationY 之后会改变它的值，也就是在滑动的时候 getY() 的值是不连续的，会出现卡顿的现象。而 getRawY() 是相对于屏幕的位置，管你控件怎么动，屏幕都是固定的。 下拉回弹的效果就已经完成了。对了，我们顺便把底部上拉的回弹也做一下呗。由于ScrollView只有一个子布局，所以可以通过 1getScrollY() + getHeight()) &gt;= getChildAt(0).getMeasuredHeight() 判断是否滑动到了底部。 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SpringScrollView extends NestedScrollView &#123; private float startDragY; private SpringAnimation springAnim; public SpringScrollView(Context context) &#123; this(context, null); &#125; public SpringScrollView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SpringScrollView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); springAnim = new SpringAnimation(this, SpringAnimation.TRANSLATION_Y, 0); //刚度 默认1200 值越大回弹的速度越快 springAnim.getSpring().setStiffness(800.0f); //阻尼 默认0.5 值越小，回弹之后来回的次数越多 springAnim.getSpring().setDampingRatio(0.50f); &#125; @Override public boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_MOVE: if (getScrollY() &lt;= 0) &#123; //顶部下拉 if (startDragY == 0) &#123; startDragY = e.getRawY(); &#125; if (e.getRawY() - startDragY &gt; 0) &#123; setTranslationY((e.getRawY() - startDragY) / 3); return true; &#125; else &#123; springAnim.cancel(); setTranslationY(0); &#125; &#125; else if ((getScrollY() + getHeight()) &gt;= getChildAt(0).getMeasuredHeight()) &#123; //底部上拉 if (startDragY == 0) &#123; startDragY = e.getRawY(); &#125; if (e.getRawY() - startDragY &lt; 0) &#123; setTranslationY((e.getRawY() - startDragY) / 3); return true; &#125; else &#123; springAnim.cancel(); setTranslationY(0); &#125; &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: if (getTranslationY() != 0) &#123; springAnim.start(); &#125; startDragY = 0; break; &#125; return super.onTouchEvent(e); &#125;&#125; 最后看看效果吧： 同样的思路也可以用在别的滑动控件里面。 妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[说一说世界上最贵的几幅画（纯属扯淡）]]></title>
      <url>%2F2017%2F03%2F18%2F201703181630%2F</url>
      <content type="text"><![CDATA[闲着没事，给大家扯一下世界上最贵的几幅画。 前言提到世界名画，大家可能会想到下面这些。 但这些都不属于我今天的讨论范围，为什么？ 如果你去故宫看到一个瓶子挺漂亮的，然后你问那里的工作人员“这瓶子怎么卖？”，他会告诉你： 不卖！！！ 所以我今天讨论的画都是真实成交了的，是世界上成交价格最贵的几幅。 嘉舍医生的肖像我们先来看看这幅画的作者，这是作者的自画像。 你可能觉得验收但不认识，但你肯定听说过他的名字—梵高！ 讲一个梵高的小故事，梵高曾经和他的一个好基友住在一个叫阿尔勒的地方。就是这里： 这幅画也是梵高画的，他的向日葵也是在这个时期画的。 某天梵高的好基友发现梵高是个神经病，然后就不跟他玩，就搬走了。事实上，梵高确实是个神经病，准确说是一个精神病患者。他的好基友走之后，他伤心欲绝，把自己的耳朵割了下来，然后他就变成了这样： 在之后的一段时间，梵高在他弟弟的安排下接受了精神病医生的治疗，这名医生就是嘉舍医生。嘉舍医生给梵高的鉴定结果是什么病都没有，梵高知道这个鉴定结果后跟他弟弟说「这家伙比我病的还厉害」。其实，嘉舍医生确实患有抑郁症，但他是个艺术爱好者，很快和梵高也成了好朋友。梵高给他画了一张肖像画。 梵高说： 我希望画一位艺术家友人的肖像，他满怀伟大的理想。我希望把我对这个人的感觉和爱慕之心画进作品里。我夸张了他的头发的金黄色，在头像后面我不画小屋的普通墙壁，而用我调配得极为丰富、极为强烈的蓝色涂出无限深远的背景。由于这种单纯的配合，使金黄色头发的头部，在这丰富的蓝色背景上发光，像星星嵌在深沉的碧空中。 画下这幅画的一个月后,梵高自杀了。 在拍卖这幅画的时候，开拍没多久，一个日本人就喊出了一个让全场人都吓尿的价格： 8250 万美元!!! 购得这幅画的是一个日本人，是一家造纸公司的老板，他死后，这幅画就下落不明了。 猫王八重影我们同样先来认识一下作者，他名叫安迪·沃霍尔。 某一天，沃霍尔突然才思泉涌，灵感大爆发。对着猫王 Ctrl + C，然后又按了两下 Ctrl + V，于是一幅杰作诞生了： 猫王三重影！！！ 你可能觉得这画好像没什么厉害的，但是它的厉害之处在于——卖出了8190万美元！ 某天沃霍尔灵机一动，又多按了几下 Ctrl + V，于是又一幅杰作诞生了 猫王八重影！！！ 据说，猫王八重影卖给了某位卡塔尔皇室成员。成交价是： 一亿美元！！！ 没有欣赏水平的我在网上搜索了一下相关的评论： 单调、无聊和重复，所传达的是某种冷漠、空虚、疏离的感觉，表现了当代高度发达的商业文明社会中人们内在的感情。 好吧，还是欣赏不来。值得一提的是，沃霍尔创作过这样一个系列，其中一幅在英国卖了 760 万英镑。 呐喊下面这幅画大家都有看过，作者是爱德华·蒙克。 一天傍晚，我和朋友走在路上，一边是城市，另一边是脚下的峡湾，我感到浑身不舒服。我停下来眺望峡湾，落日将云彩染成血一般鲜红。就在那时，我想我听到了大自然不停地尖叫。于是，我画了这幅画—将云彩画得像真正的鲜血，让色彩去吼叫。 这段话是蒙克说的关于这幅画的创作背景。我觉得这幅画应该翻译成尖叫更贴切。 这幅画所描绘的地点被人肉出来了，是挪威的一条山路。 有趣的是过去在这里附近有一个屠宰场，还有一个精神病院，所以作者当时听到的声音很可能是从屠宰场或者精神病院发出来的。 大家可能不知道，呐喊一共有四个版本。 其中 1895 年的这个版本，在 2012 年纽约以 1.19 亿美元成交。 我想再聊一下最早的这个 1893 年的版本。 1994 年 2 月 12 日，也就是挪威冬奥会开幕当天，挪威国家美术馆将「呐喊」转移到了另外一个展厅，以供展出。然后它就被偷了！第二年才被完好的追回。 2004 年 8 月 22 日（这个日期和蒙娜丽莎被偷的日期是一样的），一伙蒙面持枪者在众目睽睽之下进入蒙克博物馆。然后「呐喊」又被偷了！这张照片是当时路人拍到的，两个犯人正把画搬到自己车上。 直到两年后画才被找回，但是警方也没有说是怎么找回的，现在这幅画保存在蒙克博物馆。 阿黛拉这幅画的作者是克林姆特 这张照片看上去很文艺，其实他是个有点猥琐的人。 这是他的阿黛拉： 关于这幅画，有人把称它为「奥地利的蒙娜丽莎」，可见它的艺术地位之高。这幅画以 1.35 亿美元成交，买它的人是当时雅诗兰黛的老板，他人比较大方，把这幅画无期限的借给了纽约新画廊展出。在这幅画在纽约展出的第一年，去纽约旅游的人数增加了 20%。 大家看这幅画是不是感觉金光闪闪的，像金子一样，事实上这就是真的金子，是用金箔贴上去的，用料还是比较足的。 有关这幅画，大家有兴趣的可以看一下这部电影，叫金衣女人，讲诉了关于这幅画在近代发生的故事，是真实事件改编的。 女人 3 号 这幅画的作者叫库宁，卖了 1.375 亿美元。 关于这幅画，其实我纯粹就是想吐槽一下。这幅画画的是库宁的老婆，你肯定会想：怎么会有人把自己老婆画成这个鬼样！因为当时他老婆出轨了。所以说不要轻易得罪艺术家，不然一不小心就变成一幅世界名画了，还是以这样的形象。 你何时结婚？这是最后一幅了。还记不记得我前面说的，梵高之前跟一个好基友住一起，后来那个好基友跑了，导致梵高把耳朵割掉。这就是那个好基友，叫高更。 高更的一生充满传奇色彩，他年轻时当过水手，周游过世界，后来还当过股票经纪人，炒过股。然后突然有一天，不知道是不是他股票亏太多了，他突然说： 我想摆脱文明的影响，我只想从事非常质朴的艺术。为此我需要沉浸在未被开发的大自然中，无忧无虑，像孩童一样。借助原始艺术提供的唯一方法，描绘我大脑中的一切观念。这才是独一无二的美好真实的艺术。 然后他去了一个原始社会——塔希提岛，现在这里叫大溪地。高更在这里找到了他要的一切——脱离文明社会、有着壮观的景色、原始的自然，这里人还过着原始生活。还有这里的女人长的漂亮，还经常不穿衣服。所以据说高更在那里过上了很幸福的生活。 这是高更在岛上画的画中的一幅，叫你何时结婚，这幅画是目前艺术品成交价格最高的记录保持着，大家猜一下它卖了多少钱？ 三亿美元！ 据说是给一个卡塔尔博物馆买走了。 总结上面这些画虽然千奇百怪，但是他们有一个共同点：有个性！ 知道这些有什么用？如果以后大家有机会去美术馆，就可以装一下了。 看到线条扭曲，颜料像不要钱一样往上面抹的，就是梵高的作品。 看到拿某个名人复制粘贴的就是沃霍尔。 线条很夸张，让人感觉很压抑的，就是蒙克。 往画上面贴金的，是克林姆特。 画了一个丑女人的，是库宁。 在一片原始森林里，有几个黑女人的，是高更。 妥妥的。 就到这吧，谢谢大家看我扯淡。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[像 QQ 一样处理滑动冲突]]></title>
      <url>%2F2017%2F03%2F12%2F201703121142%2F</url>
      <content type="text"><![CDATA[在项目中，如果要用到滑动控件嵌套滑动控件，总会让人很心塞。因为很可能会出现冲突的问题。这里举个例子，利用事件分发机制，处理侧滑菜单控件和列表中的侧滑删除控件间的冲。 分析提到侧滑删除，一个经典的例子就是 QQ 了。QQ 的首页是一个大的侧滑菜单控件，嵌套一个列表，列表里面再嵌套侧滑删除的控件。我们就仿照这个样式，看看能不能做一个和它类似的效果。 这里关注的重点是在滑动手势的处理上，简单分析一下需要做什么处理： （下面把侧滑菜单控件称作菜单控件，列表侧滑删除控件称作删除控件。） 在首页上下滑动时，滚动列表。 菜单控件关闭的情况下，如果列表里面没有展开的删除项，则手指向右滑动是滑动菜单控件，向左滑动是滑动删除控件。 如果列表里面有展开的删除控件，则菜单控件和列表项都不可滑动。除了删除按键，点击其他区域，都是将展开项关闭。 当手指滑动删除控件时，手指滑动到屏幕的任意区域都可以滑动展开项。 菜单控件打开的情况下，点击右边主页区域，将菜单控件关闭。 有点复杂的感觉啊，我们一个个来解决。 我自定义了上面说到的三个控件，根据嵌套关系，从大到小分别是： 菜单控件 SwipeMenuLayout 列表控件 MyRecyclerView 删除控件 SwipeDeleteLayout 其中，SwipeMenuLayout 和 SwipeDeleteLayout 都是继承自 FrameLayout，用 ViewDragHelper 实现滑动效果。MyRecyclerView 则继承自 RecyclerView。 我们知道事件分发和三个方法有关： 负责分发的 dispatchTouchEvent 负责拦截的 onInterceptTouchEvent 负责消费的 onTouchEvent 简单概括一下这个机制就是：分发从父到子，消费从子到父。 一般我们不对分发做特殊处理，下面按执行顺序看看三个控件的 onInterceptTouchEvent 和 onTouchEvent 方法是怎么写的。 onInterceptTouchEventonInterceptTouchEvent 方法的返回值决定是否拦截事件。 菜单控件这部分要稍微啰嗦一点。我们先看看菜单关闭的情况，这时如果手指向右滑且没有展开的删除控件，我们就可以把事件拦截了，所以 onInterceptTouchEvent 可以写成这样： 123456789101112131415161718192021if (mState == State.CLOSE) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mDownX = ev.getRawX(); mDownY = ev.getRawY(); &#125; break; case MotionEvent.ACTION_MOVE: &#123; float deltaX = ev.getRawX() - mDownX; float deltaY = ev.getRawY() - mDownY; //向右滑动且列表没有展开项且横向滑动距离比竖向滑动距离大，则拦截 if (deltaX &gt; 0 &amp;&amp; MainAdapter.mOpenItems.size() == 0 &amp;&amp; Math.abs(deltaY / deltaX) &lt; 1) &#123; return true; &#125; &#125; break; &#125;&#125; mState 代表当前侧滑控件的状态，MainAdapter.mOpenItems 保存的是当前打开的删除控件。我使用 Math.abs(deltaY / deltaX) 是否小于 1 来判断手指的滑动方向。 这里还有两种不拦截的情况，向左滑动或者有展开项的话，都是和侧滑菜单没关系的，滑动事件里面再加入以下代码： 123456//如果是向左滑，且竖直滑动距离大于横向滑动距离，不拦截//MainPage打开的item个数大于0，不拦截if ((deltaX &lt; 0 &amp;&amp; Math.abs(deltaY / deltaX) &gt; 1) || MainAdapter.mOpenItems.size() &gt; 0) &#123; return false;&#125; 接下来是菜单打开的情况。这时候当手指点击了右侧的主页面区域是需要拦截并且将菜单关闭。如果手指向右滑动则不需要拦截： 123456789101112131415161718if (mState == State.OPEN) &#123; //完全展开时并且点到主页面，拦截并关闭菜单 if (mMainContent.getLeft() &lt;= mRange &amp;&amp; ev.getRawX() &gt; mRange) &#123; return true; &#125; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = ev.getRawX(); break; case MotionEvent.ACTION_MOVE: //如果是向右滑，不拦截 float deltaX = ev.getRawX() - mDownX; if (deltaX &gt; 0) &#123; return false; &#125; break; &#125;&#125; mRange是侧滑出来的菜单宽度，关闭菜单的操作可以放在 ViewDragHelper 的 Callback 方法处理。 除了上面这些情况，默认情况下是否拦截交给 ViewDragHelper 处理就好了，调用它的 shouldInterceptTouchEvent 方法。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (mState == State.CLOSE) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mDownX = ev.getRawX(); mDownY = ev.getRawY(); &#125; break; case MotionEvent.ACTION_MOVE: &#123; float deltaX = ev.getRawX() - mDownX; float deltaY = ev.getRawY() - mDownY; //向右滑动且列表没有展开项且横向滑动距离比竖向滑动距离大，则拦截 if (deltaX &gt; 0 &amp;&amp; MainAdapter.mOpenItems.size() == 0 &amp;&amp; Math.abs(deltaY / deltaX) &lt; 1) &#123; return true; &#125; //如果是向左滑，且竖直滑动距离大于横向滑动距离，不拦截 //MainPage打开的item个数大于0，不拦截 if ((deltaX &lt; 0 &amp;&amp; Math.abs(deltaY / deltaX) &gt; 1) || MainAdapter.mOpenItems.size() &gt; 0) &#123; return false; &#125; &#125; break; &#125; &#125; else if (mState == State.OPEN) &#123; //完全展开时并且点到主页面，拦截并关闭菜单 if (mMainContent.getLeft() &lt;= mRange &amp;&amp; ev.getRawX() &gt; mRange) &#123; return true; &#125; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = ev.getRawX(); break; case MotionEvent.ACTION_MOVE: //如果是向右滑，不拦截 float deltaX = ev.getRawX() - mDownX; if (deltaX &gt; 0) &#123; return false; &#125; break; &#125; &#125; return mDragHelper.shouldInterceptTouchEvent(ev);&#125; 列表控件列表里面其实只做了一个处理，就是判断上下滑动的时候就把事件拦截了： 12345678910111213141516171819@Overridepublic boolean onInterceptTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = e.getRawX(); mDownY = e.getRawY(); break; case MotionEvent.ACTION_MOVE: //竖向滑动时拦截事件 float deltaX = e.getRawX() - mDownX; float deltaY = e.getRawY() - mDownY; if (deltaY != 0.0 &amp;&amp; Math.abs(deltaX / deltaY) &lt; 1) &#123; return true; &#125; break; &#125; return super.onInterceptTouchEvent(e);&#125; 删除控件这里什么都不用做，交给 ViewDragHelper 就好了： 123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev);&#125; onTouchEventonTouchEvent 方法的返回值决定是否消费事件。 删除控件删除控件的 onTouchEvent 又有几个地方要做特殊处理的。当有展开的删除项时，点击别的删除项时就将展开的关闭。这样就可以了： 1234//存在已展开的控件且当前控件为关闭状态，则将所有展开控件关闭if (MainAdapter.mOpenItems.size() &gt; 0 &amp;&amp; mState == State.CLOSE) &#123; return false;&#125; 这里我没有消费事件，也没有进行关闭的操作，因为我把关闭的操作交给父控件去处理了，否则会有卡顿的现象（QQ 就有这个问题）。 如果点击的是展开的删除项左边区域，这个又比较特殊了。因为手指按下之后，有可能是滑动，也可能是点击。滑动的话是滑动删除项，点击则是将删除项关闭。所以我们要判断一下用户是否有滑动的操作: 12345678910111213141516171819switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = event.getRawX(); break; case MotionEvent.ACTION_MOVE: float deltaX = event.getRawX() - mDownX; if (Math.abs(deltaX) &gt; 50) &#123; isDrag = true; &#125; break; case MotionEvent.ACTION_UP: if (!isDrag &amp;&amp; event.getRawX() &lt;= mWidth - mBackWidth) &#123; close(); return true; &#125; isDrag = false; break;&#125; 当滑动距离大于 50 时，我就把它当做是一个滑动操作，这时候把滑动交给 ViewDragHelper 处理，否则就将当前控件关闭。 最后还有一个，当我滑动删除控件时，如果手指滑到了别的地方，滑动的依然是当前这个删除控件。换一个说法，其实就是一旦滑动了，父控件就不能再拦截我的滑动事件了。其实 ViewGroup 里面有一个 requestDisallowInterceptTouchEvent 方法，传 true 的时候，相当于通知它的所有父控件不要再拦截了。所以可以这样来处理： 1234567891011switch (event.getAction()) &#123; case MotionEvent.ACTION_MOVE: requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_CANCEL: requestDisallowInterceptTouchEvent(false); break; case MotionEvent.ACTION_UP: requestDisallowInterceptTouchEvent(false); break;&#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536public boolean onTouchEvent(MotionEvent event) &#123; //存在已展开的控件且当前控件为关闭状态，则将所有展开控件关闭 if (MainAdapter.mOpenItems.size() &gt; 0 &amp;&amp; mState == State.CLOSE) &#123; MainAdapter.closeAll(); return true; &#125; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = event.getRawX(); break; case MotionEvent.ACTION_MOVE: requestDisallowInterceptTouchEvent(true); float deltaX = event.getRawX() - mDownX; if (Math.abs(deltaX) &gt; 50) &#123; isDrag = true; &#125; break; case MotionEvent.ACTION_CANCEL: requestDisallowInterceptTouchEvent(false); break; case MotionEvent.ACTION_UP: requestDisallowInterceptTouchEvent(false); if (!isDrag &amp;&amp; event.getRawX() &lt;= mWidth - mBackWidth) &#123; //展开状态下，点击左侧部分将其关闭 close(); return true; &#125; isDrag = false; break; &#125; mDragHelper.processTouchEvent(event); return true;&#125; 列表控件当有展开删除项且点击了别的删除项的时候，把关闭的操作继续往父控件抛就好了： 123public boolean onTouchEvent(MotionEvent e) &#123; return MainAdapter.mOpenItems.size() == 0 &amp;&amp; super.onTouchEvent(e);&#125; 菜单控件在这里处理一下上面说的那种情况： 12345678public boolean onTouchEvent(MotionEvent event) &#123; if (MainAdapter.mOpenItems.size() &gt; 0) &#123; MainAdapter.closeAll(); return true; &#125; mDragHelper.processTouchEvent(event); return true;&#125; 效果扯了这么多，看下效果吧： 搞半天其实也就这么样而已。 小结这篇有点啰嗦啊，里面涉及到的细节比较多。最后可能还会存在一些问题，这里主要是提供利用事件分发机制，处理手势冲突的思路。 写这个的时候发现 QQ 也有一些小问题，比如 QQ 在删除控件展开的情况下，按住删除控件左边区域下滑后，再左右滑，会出现列表跳动的问题。 大家可以点下面去看源码。就到这吧，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 2.3 正式版发布！看看有什么新功能]]></title>
      <url>%2F2017%2F03%2F04%2F201703041507%2F</url>
      <content type="text"><![CDATA[Android Studio 2.3 正式版发布了！来看看我们的劳动工具 2.3 有什么新功能吧！ 编译Instant Run工具栏上增加了一个“闪电”的标志，原来的 “Run” 按钮（Shift+F10）会保持全量编译。新增的“闪电”按钮（Gradle 需要升级到 2.3.0）才是 Instant Run，会在程序保持运行的情况下替换代码。 Instant Run 的底层代码有很大的改进，消除了的启动延时。 编译缓存使用编译缓存可以加快编译的速度。在 Android Studio 2.2 已经引进了编译缓存，但默认是关闭的。Android Studio 2.3 的编译缓存得到进一步优化，使用后的编译速度将会更快，而且是默认打开的。 设计约束布局（ConstraintLayout）Android Studio 2.3 包含了稳定版的 ConstraintLayout（意思是 2.2 里面的是不稳定版？！），现在可以将两个或以上的控件在一个维度上建立成一组，平铺在它们的父布局里。 支持按固定的比例缩放图片。 布局编辑器新的布局编辑器支持通过搜索、排序和过滤找到对应的控件，并且增加了一个预览的窗口。 布局属性收藏在布局的控件属性编辑窗口里面可以保存控件的属性，在对应属性左边点亮星号保存，被保存的属性将会出现在属性编辑窗口的 Favorites Attributes 栏下。 WebP图片格式在 Android Studio 2.3 里面支持将 PNG 格式的图片转换为 WebP 格式，WebP 格式的占用空间要比 PNG 格式小 25% 以上，并且是无损的。这将帮助减小 APK 的大小。要转换，只需右键 PNG 格式图片，点击 PNG file to convert to WebP 就可以了，也支持将 WebP 格式的图片恢复到 PNG 格式。 Material图标向导新的 Material 图标向导支持搜索和过滤。 开发Lint BaselineLint 是 Android Stuido 里面一个检查代码的功能，它可以查出不规范的代码、多余的资源、可能存在的bug等问题。可以通过 Analyze → Inspect Code 启用。 现在 Android Stuido 2.3 给它增加了一个小功能，可以将没有解决的Lint警告作为 Baseline，Baseline 只会显示新的警告。如果项目里面有很多的 Lint 警告，但是你只想去处理新的警告，就可以用上这个功能。 App 链接使用新的 App 链接助手可以很方便地创建 url 意图过滤器，并且支持测试。通过 Tools → App Link Assistant 打开 App 链接助手。 模板在模板里面，原来使用了 RelativeLayout 的布局现在替换成了 ConstraintLayout。 增加了一个带有底部导航栏的模板，遵循了材料设计的底部导航设计规范。 调试模拟器模拟器里面增加了 Pixel 和 Pixel XL。 模拟器支持和主机操作系统共享粘贴板，也就是可以互相复制粘贴了。需要使用 x86 Google API，并且 API 19（Android 4.4）以上的模拟器。 小结Android Stuido 2.3 带来的改进还是挺多的。 首先，编译速度又快了一些，我把关掉的 Instant Run 又打开了（咦？我为什么要说又）。 作为习惯写xm代码的码农来说，估计还没怎么用过 ConstraintLayout。谷歌从 16 年开发者大会之后就一直在推 ConstraintLayout，这次连默认模板里面的布局都改成了 ConstraintLayout 了，感觉是时候要了解一下了。 关于 WebP 格式，官方说可以减少 25% 以上的容量。我随便找了一张图片转，居然只有原来 5% 的大小。如果项目里面用到的图片比较多，可以在很大程度上减小 apk 的大小。 说实话，之前没怎么用过 Lint 检查代码。一旦用上了，作为一名不允许有一根黄线存在的强迫症患者，感觉又多了一些工作量。 就到这吧。妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Scalpel 3D 展示界面布局]]></title>
      <url>%2F2017%2F02%2F25%2F201702251837%2F</url>
      <content type="text"><![CDATA[无意中了解到 iOS 开发里面有一个叫 Reveal 的神器，用于 UI 调试。要是俺们安卓也能实现类似效果就好了。 Reveal 看上去是这个样子的： 很酷炫有木有！ 什么？Jake Wharton 大神早在几年前就给我们准备了类似的开源库了！ 今天要介绍的就是大神的 Scalpel，可以实现在手机上 3D 展示届满布局，而且用起来超级简单！ 在 Gradle 中引入 Scalpel： 1compile &apos;com.jakewharton.scalpel:scalpel:1.1.2&apos; 然后我们来到需要展示效果的布局文件，将它的根布局修改为 ScalpelFrameLayout，看名字也能猜到它是继承 FrameLayout 的。（要是去看源码你会发现，其实整个库只有 ScalpelFrameLayout这一个文件，四百多行代码，膜拜大神！） 然后在代码里面将 setContentView 修改成以下代码： 123456789View mainView = getLayoutInflater().inflate(R.layout.activity_main, null);ScalpelFrameLayout mScalpelFrameLayout = new ScalpelFrameLayout(this);mScalpelFrameLayout.addView(mainView);mScalpelFrameLayout.setLayerInteractionEnabled(true); //开启3D效果//mScalpelFrameLayout.setDrawIds(true); //是否显示控件id//mScalpelFrameLayout.setDrawViews(false); //是否展示控件内容，默认为true//mScalpelFrameLayout.setChromeColor(Color.RED); //修改边框颜色//mScalpelFrameLayout.setChromeShadowColor(Color.YELLOW); //修改阴影颜色setContentView(mScalpelFrameLayout); 跑一下看看效果： 妥妥的。 你问我有什么用？酷炫啊！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给 RecyclerView 加上折叠的效果]]></title>
      <url>%2F2017%2F02%2F18%2F201702181254%2F</url>
      <content type="text"><![CDATA[RecyclerView有很高的自由度，可以说只有想不到没有做不到，真是越用越喜欢。这次用超简单的方法，让 RecyclerView 带上折叠的效果。 效果是这样的。 总结一下这个列表的特点，就是以下三点： 重叠效果； 层次感； 首项的差动。 下面我们来一个个解决。 我们新建一个 ParallaxRecyclerView，让它继承 RecyclerView，并使用LinearLayoutManager作为布局管理器。 重叠效果其实就是每一项都搭一部分在它前面那项而已。我们知道，RecyclerView 可以通过设置 ItemDecoration 来实现列表的间隔效果，有没有想过要是把间隔设为负数会怎么样？比如： 1234567addItemDecoration(new ItemDecoration() &#123; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.bottom = -dp2px(context, 10); &#125; &#125;); 没错，这就实现了我们的重叠效果。 层次感在 Material Design 里是有Z轴这个概念的，我们可以给控件设置垂直于屏幕的高度，让不在同一高度的控件看起来有层次感。当然，我们要用 Material Design 的控件才有这个属性，这里我用的是 CardView。 我们给 ParallaxRecyclerView 增加一个滑动监听，在 onScrolled 方法里面做如下设置： 12345678910111213141516LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();int firstPosition = layoutManager.findFirstVisibleItemPosition();int lastPosition = layoutManager.findLastVisibleItemPosition();int visibleCount = lastPosition - firstPosition;//重置控件的高度int elevation = 1;for (int i = firstPosition - 1; i &lt;= (firstPosition + visibleCount) + 1; i++) &#123; View view = layoutManager.findViewByPosition(i); if (view != null) &#123; if (view instanceof CardView) &#123; ((CardView) view).setCardElevation(dp2px(context, elevation)); elevation += 5; &#125; &#125;&#125; 其中，setCardElevation 方法就是用来给 CardView 设置高度的，这里让每一项的高度比它的上一项高 5dp。 首项的差动最后，我们想给第一项增加一个差动效果，这个同样在 onScrolled 方法里面做处理就好了： 123View firstView = layoutManager.findViewByPosition(firstPosition);float firstViewTop = firstView.getTop();firstView.setTranslationY(-firstViewTop / 2.0f); 这样相当于第一项的滑动速度变成原来的一半。但这也会导致一个问题， 由于改变了控件的位置，当这个控件被复用时，会出现位置不正确的情况。所以我们在设置高度的时候，可以顺便把控件的位置复原了： 1234 float translationY = view.getTranslationY();if (i &gt; firstPosition &amp;&amp; translationY != 0) &#123; view.setTranslationY(0);&#125; 这样就完成了一个带有简单折叠效果的 RecyclerView 了，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单实现带节点的进度条]]></title>
      <url>%2F2017%2F02%2F05%2F201702051620%2F</url>
      <content type="text"><![CDATA[带节点进度条的实现方法不止一个，但是如果要实现图中这种效果的，初步看好像还不简单。进度条的形状不规则、背景是渐变颜色、节点上面还有个勾。这里提供一个很简单的思路，简单的都不好意思说了…… 为了实现这个效果，我们需要三张图片，就是下面这三张。 看到这里可能你已经知道要怎么做了，三张图片分别是： 1.进度条填充部分的背景，带渐变颜色带节点小勾2.进度条未填充部分的背景，纯色3.进度条外框背景，是一张镂空图，颜色和进度条外的颜色一致 注意这三张图片的大小必须一致，将这三张图片叠加到一起就是我们的进度条了。至于进度条的动画，我们只要对第二层的那张图片实现一个属性动画就可以了： 12345678public void setProgress(float stage) &#123; int progressWidth = ivProgress.getWidth(); ObjectAnimator animator = ObjectAnimator.ofFloat(ivProgress, "translationX", stage * progressWidth); animator.setDuration((int) (Math.abs(stage - currentStage) * 1000)); animator.start(); currentStage = stage;&#125; 至于如何控制到哪一个节点，这个可以自己拿尺子量一下，多试几次，上面代码中的 stage 就是这个作用，它从这里取值： 12345678//不同阶段进度条所在位置public static final float STAGE0 = 0f;public static final float STAGE1 = 0.046f;public static final float STAGE2 = 0.285f;public static final float STAGE3 = 0.523f;public static final float STAGE4 = 0.761f;public static final float STAGE5 = 1f; 最后看一下效果。 这样就已经实现了一个看上去有点复杂的进度条了，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[避免重复吐司( Toast )时，显示时间过长]]></title>
      <url>%2F2017%2F01%2F08%2F201701081106%2F</url>
      <content type="text"><![CDATA[当短时间内多次调用 Toast.makeText 方法时，会出现吐司显示的内容显示时间过长，或者当前吐司没有显示最新内容的情况。 这是因为吐司会像排队一样，每一个吐司都会有自己固定的时间（短吐司为 2 秒，长吐司为 3.5 秒），新的吐司需要在前面的吐司显示结束之后才会出现。解决这种情况也很简单。 在公共的工具类里面，增加这样一个方法来弹吐司： 123456789101112131415public void showToast(Context context, String text, boolean isLongLength) &#123; int length; if (isLongLength) &#123; length = Toast.LENGTH_LONG; &#125; else &#123; length = Toast.LENGTH_SHORT; &#125; if (toast == null) &#123; toast = Toast.makeText(context, text, length); &#125; else &#123; toast.setText(text); toast.setDuration(length); &#125; toast.show();&#125; 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给 Android 图表库 MPAndroidChart 的坐标换行]]></title>
      <url>%2F2016%2F12%2F13%2F201612132202%2F</url>
      <content type="text"><![CDATA[做统计图时，经常会有这样的需求：x 坐标需要换行显示，日和月或者是月和年需要分两行显示。但是找遍 MPAndroidChart 的各种教程，好像也没有相关的方法可以实现…… 首先，MPAndroidChart 确实是没有提供更改坐标换行显示的方法。在看这篇文章之前，你可能已经尝试过实现一个 ValueFormatter，或者是 “\r\n” 这样的挣扎，发现并没有什么卵用。但就算真给你换行了，如何居中，如何设置两行不同字体也是问题。 咋办？看一下源码吧。看看设进去的数据是如何显示出来的。 以 LineChart 为例，我们是这样来设置坐标轴要显示的内容的： 123LineData data = new LineData(xValues, dataSets);mChart.setData(data);mChart.invalidate(); 跟着 setData 方法进源码，一路经过 Chart，BarLineChartBase，最终来到了 XAxisRenderer 这个类，我们的 xValues 被赋值给了它的 mXAxis。然后，好像就没有然后了…… 不对，别忘了我们 setData 之后还调用了 invalidate 方法请求重绘，重绘会去调用 Chart 的 onDraw 方法。再看看继承 Chart 的 BarLineChartBase，它的 onDraw 方法里出现了这一句: 1this.mXAxisRenderer.renderGridLines(canvas); 感觉离真相越来越近了。我们再跟着这个方法进来，看到里面调用了 drawLabels 方法，然后 drawLabels 又调用了 drawLabel 方法，最终我们来到了这里： 1234protected void drawLabel(Canvas c, String label, int xIndex, float x, float y, PointF anchor,float angleDegrees) &#123; String formattedLabel = mXAxis.getValueFormatter().getXValue(label, xIndex,mViewPortHandler); Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees);&#125; 最后进入 Utils.drawXAxisValue 方法，终于看到了这样的一句： 1c.drawText(text, drawOffsetX, drawOffsetY, paint); 哎呦我去，终于找到了，藏这么深。 可以看到坐标轴是用 Canvas.drawText 显示出来的。了解一下你会发现，通常情况下， drawText 方法是不支持 “\n\r” 的。看来我们只要改 drawLabel 这个方法就可以了。由于源码几个类的耦合程度比较高，我并没有找到可以通过继承重写的方法实现，不得已只好改源代码了。 我修改后的代码是这样的： 1234567891011121314151617181920212223242526protected void drawLabel(Canvas c, String label, int xIndex, float x, float y, PointF anchor, float angleDegrees) &#123; String formattedLabel = mXAxis.getValueFormatter().getXValue(label, xIndex, mViewPortHandler); float labelHeight = mXAxis.getTextSize(); float labelInterval = 25f; String[] labels = label.split(" "); Paint mFirstLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mFirstLinePaint.setColor(Color.WHITE); mFirstLinePaint.setTextAlign(Align.CENTER); mFirstLinePaint.setTextSize(Utils.convertDpToPixel(15f)); mFirstLinePaint.setTypeface(mXAxis.getTypeface()); Paint mSecondLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mSecondLinePaint.setColor(0xFF9b9b9b); mSecondLinePaint.setTextAlign(Align.CENTER); mSecondLinePaint.setTextSize(Utils.convertDpToPixel(10f)); mSecondLinePaint.setTypeface(mXAxis.getTypeface()); if (labels.length &gt; 1) &#123; Utils.drawXAxisValue(c, labels[0], x, y, mFirstLinePaint, anchor, angleDegrees); Utils.drawXAxisValue(c, labels[1], x, y + labelHeight + labelInterval, mSecondLinePaint, anchor, angleDegrees); &#125; else &#123; Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees); &#125;&#125; 我在要分行显示的字符串间加了个空格，在这里再用空格切割成两个字符串。我们可以分别给两行设置不同的格式，并且让他们都居中显示。最后绘制的时候，把第二行的 y 坐标改一下，在第一行的基础上加上一定的高度就可以了。妥妥的。 另外，那条黄色的高亮线也是改源码实现的。 2017.2.19 更新 MPAndroidChart 3.0 之后改变比较大，和这里相关的主要有两点： 取消了 LineData(List xVals, List dataSets) 这个构造方法，不再传x轴坐标数据，直接从 LineDataSet 坐标中获取。 MPAndroidChart 底层绘制X轴坐标，是先格式化之后才执行 drawLabel 这个方法。 处理的思路跟之前是一致的，可以用 ValueFormatter 格式化一下X轴的数据（比如用空格将要分行显示的数据分开），然后修改源码 XAxisRenderer 里面的 drawLabel，类似下面这样： 123456789101112131415161718192021222324protected void drawLabel(Canvas c, String formattedLabel, float x, float y, MPPointF anchor, float angleDegrees) &#123; float labelHeight = mXAxis.getTextSize(); float labelInterval = 25f; String[] labels = formattedLabel.split(" "); Paint mFirstLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mFirstLinePaint.setColor(Color.WHITE); mFirstLinePaint.setTextAlign(Align.CENTER); mFirstLinePaint.setTextSize(Utils.convertDpToPixel(15f)); mFirstLinePaint.setTypeface(mXAxis.getTypeface()); Paint mSecondLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mSecondLinePaint.setColor(0xFF9b9b9b); mSecondLinePaint.setTextAlign(Align.CENTER); mSecondLinePaint.setTextSize(Utils.convertDpToPixel(10f)); mSecondLinePaint.setTypeface(mXAxis.getTypeface()); if (labels.length &gt; 1) &#123; Utils.drawXAxisValue(c, labels[0], x, y, mFirstLinePaint, anchor, angleDegrees); Utils.drawXAxisValue(c, labels[1], x, y + labelHeight + labelInterval, mSecondLinePaint, anchor, angleDegrees); &#125; else &#123; Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees); &#125;&#125; 妥妥的。 2017.3.17 更新 补充一下高亮线的修改方法吧。 如果用的是不规则的高亮线（像图片里面上下有个球的），需要用自己的图片资源来替换。为了适配，建议使用高度可以拉伸的点九图。 我们先找到接口 ILineScatterCandleRadarDataSet，增加一个获取 Bitmap 的方法： 1234/** * @return 获取高亮线图片 bitmap */Bitmap getHighLightBitmap(); 再找到 LineScatterCandleRadarDataSet，增加这两个方法： 1234567891011121314151617protected Bitmap mHighlightBitmap = null;/** * 设置高亮线图片 * * @param bitmap 高亮线图片 bitmap */public void setHighlightBitmap(Bitmap bitmap) &#123; this.mHighlightBitmap = bitmap;&#125;/** * @return 获取高亮线图片 bitmap */public Bitmap getHighLightBitmap() &#123; return this.mHighlightBitmap;&#125; 最后找到设置高亮线的地方，它在 LineScatterCandleRadarRenderer 的 drawHighlightLines 方法里，可以把它修改成这个样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Draws vertical &amp; horizontal highlight-lines if enabled. * * @param c * @param x x-position of the highlight line intersection * @param y y-position of the highlight line intersection * @param set the currently drawn dataset */protected void drawHighlightLines(Canvas c, float x, float y, ILineScatterCandleRadarDataSet set) &#123; // set color and stroke-width mHighlightPaint.setColor(set.getHighLightColor()); mHighlightPaint.setStrokeWidth(set.getHighlightLineWidth()); // draw highlighted lines (if enabled) mHighlightPaint.setPathEffect(set.getDashPathEffectHighlight()); //优先使用高亮线图片显示，没有则使用默认样式 if (set.getHighLightBitmap() != null) &#123; if (set.isVerticalHighlightIndicatorEnabled()) &#123; Bitmap highLightBitmap = set.getHighLightBitmap(); NinePatch ninePatch = new NinePatch(highLightBitmap, highLightBitmap.getNinePatchChunk(), null); int highLightWidth = (int) Utils.convertDpToPixel(8.0F); RectF rectF = new RectF(x - (float) (highLightWidth / 2), this.mViewPortHandler.contentTop(), x + (float) (highLightWidth / 2), this.mViewPortHandler.contentBottom()); ninePatch.draw(c, rectF); &#125; &#125; else &#123; // draw vertical highlight lines if (set.isVerticalHighlightIndicatorEnabled()) &#123; // create vertical path mHighlightLinePath.reset(); mHighlightLinePath.moveTo(x, mViewPortHandler.contentTop()); mHighlightLinePath.lineTo(x, mViewPortHandler.contentBottom()); c.drawPath(mHighlightLinePath, mHighlightPaint); &#125; // draw horizontal highlight lines if (set.isHorizontalHighlightIndicatorEnabled()) &#123; // create horizontal path mHighlightLinePath.reset(); mHighlightLinePath.moveTo(mViewPortHandler.contentLeft(), y); mHighlightLinePath.lineTo(mViewPortHandler.contentRight(), y); c.drawPath(mHighlightLinePath, mHighlightPaint); &#125; &#125;&#125; 上面代码基于目前最新的 MPAndroidChart 3.0.1 ，旧版在细节上会有不同，但实现思路是一致的。 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现列表悬浮标签「顶上去」的效果]]></title>
      <url>%2F2016%2F11%2F27%2F201611272038%2F</url>
      <content type="text"><![CDATA[列表顶部的标签悬浮大家应该都知道，但「顶上去」是个啥玩意？ 看一下效果图就知道了，注意看顶部的悬浮标签切换时的效果： 这是我在之前一个自定义侧边索引栏的项目上修改的，对侧边索引栏的实现有兴趣的可以看一下之前的文章：自定义侧边快速索引栏 思路是这样子的： 布局里面增加一个和索引item长的一样的view，默认显示列表第一项的索引字母。 监听列表的滑动，当列表可见的第二项是索引item时，计算并更新悬浮view的Y坐标，让它处于索引item的上方。 监听列表的滑动，当列表可见第一项发生变化时，更新悬浮view显示的字母为当前可见第一项的索引字母。 感觉比想象中简单啊。可以看出逻辑都是在滑动事件里，我们用RecyclerView的addOnScrollListener方法监听列表的滑动事件，在监听器里面实现上面的逻辑。说的可能不是很好，看代码就知道多简单了。 监听器的代码如下： 12345678910111213141516171819202122232425262728293031323334353637class mScrollListener extends RecyclerView.OnScrollListener &#123; private int mFlowHeight; private int mCurrentPosition = -1; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; mFlowHeight = vFlow.getMeasuredHeight(); &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; int firstVisibleItemPosition = layoutManager.findFirstVisibleItemPosition(); View view = layoutManager.findViewByPosition(firstVisibleItemPosition + 1); if (view != null) &#123; if (view.getTop() &lt;= mFlowHeight &amp;&amp; isItem(firstVisibleItemPosition + 1)) &#123; vFlow.setY(view.getTop() - mFlowHeight); &#125; else &#123; vFlow.setY(0); &#125; &#125; if (mCurrentPosition != firstVisibleItemPosition) &#123; mCurrentPosition = firstVisibleItemPosition; tvFlowIndex.setText(mList.get(mCurrentPosition).getFirstWord()); &#125; &#125; /** * @param position 对应项的下标 * @return 是否为标签项 */ private boolean isItem(int position) &#123; return mAdapter.getItemViewType(position) == MainAdapter.VIEW_INDEX; &#125;&#125; 这样就已经实现「顶上去」的效果了，妥妥的。 最后说明一下，这个代码是使用 RecyclerView 实现的，要是用 ListView 的话是有问题的。ListView的item 使用 getTop() 方法，刚开始拿到的应该是 item 距离整个 ListView 最顶部的距离，要都是这样还好处理，但是复用item的时候这个值又发生了变化。总之就是，在使用 ListView 的时候，我还没有好的实现方法。要是哪位知道怎么实现，希望可以留言分享一下，不胜感激！ 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现一个带浮动标签的输入框]]></title>
      <url>%2F2016%2F11%2F27%2F201611271321%2F</url>
      <content type="text"><![CDATA[现在带浮动标签的输入框也是一个很常见的东西了，在材料设计里面有一个 TextInputLayout 的控件，我们可以用它实现这个效果。但是材料设计控件的样式比较固定，并不能满足我们产品设计的脑洞。这里提供一个用属性动画实现的方法。 还是先看看效果吧： 大概的思路是这样的： 控件有两层，一层是浮动的标签，一层是输入框。 当点击控件后，标签同时执行一个横向和纵向的缩放动画，还有一个向上移动的动画，让输入框获取到焦点并弹出键盘。 当输入框失去焦点时，判断是否有内容，如果没有则让标签执行一个复原的动画。 下面看看控件的布局： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/fl_content" android:layout_width="match_parent" android:layout_height="55dp" android:background="@color/white" android:orientation="vertical" android:paddingLeft="20dp"&gt; &lt;EditText android:id="@+id/et_content_name" android:layout_width="match_parent" android:layout_height="30dp" android:layout_gravity="center_vertical" android:background="@color/white" android:textColor="@color/black" android:textCursorDrawable="@null" android:textSize="14sp" android:visibility="gone" /&gt; &lt;TextView android:id="@+id/tv_content_hint" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:text="标题" android:textColor="@color/text_gray" android:textSize="14sp" android:transformPivotX="0dp" android:transformPivotY="-30dp" /&gt;&lt;/FrameLayout&gt; 由于 EditText 会默认获取到焦点，所以我先把它隐藏了。这里面值得注意的是 transformPivotXY 这个参数，等下会讲到。 然后我们创建标签向上缩放的方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435public void animationUp() &#123; ObjectAnimator scaleX = ObjectAnimator.ofFloat(tvHint, "scaleX", 0.6f); ObjectAnimator scaleY = ObjectAnimator.ofFloat(tvHint, "scaleY", 0.6f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(100); animatorSet.setInterpolator(new DecelerateInterpolator()); animatorSet.play(scaleX).with(scaleY); //两个动画同时开始 animatorSet.start(); animatorSet.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; etContent.setVisibility(View.VISIBLE); etContent.requestFocus(); //弹出键盘 InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(etContent, 0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;);&#125; 代码不难理解，就是同时执行了横向和纵向的缩放动画，让标签缩小到 60%。动画执行完后显示 EditText，让它获取到焦点并弹出键盘。如果 animatorSet.setInterpolator(new DecelerateInterpolator()); 这句不懂的话，看看下面这张图就明白了： 到这里，你可能还有的一个疑问就是，向上移动的动画呢？缩放动画是根据控件的基准坐标来进行缩放的。也就是说，当我们把基准坐标设在控件上方时，缩放的时候也会有一个移动的效果。所以在布局里面用 12android:transformPivotX=&quot;0dp&quot;android:transformPivotY=&quot;-30dp&quot; 将标签的基准点设为(0dp, -30dp)，这样我们就省去了移动动画。 至于复原的动画，就更简单了： 123456789101112public void animationDown() &#123; etContent.setVisibility(View.GONE); ObjectAnimator scaleX = ObjectAnimator.ofFloat(tvHint, "scaleX", 1); ObjectAnimator scaleY = ObjectAnimator.ofFloat(tvHint, "scaleY", 1); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(100); animatorSet.setInterpolator(new DecelerateInterpolator()); animatorSet.play(scaleX).with(scaleY); //两个动画同时开始 animatorSet.start();&#125; 为了实现失去焦点，标签复原，我们需要监听输入框是否有焦点： 12345678etContent.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View view, boolean b) &#123; if (!b &amp;&amp; TextUtils.isEmpty(etContent.getText())) &#123; animationDown(); &#125; &#125;&#125;); 这样就已经完成了一个带浮动标签的输入框，妥妥的。 虽然实现一个这样的控件不难，但我个人还是希望可以使用原生控件的，希望移动端的设计能多去了解一下材料设计吧。(T_T)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决用 drawBitmap 绘制点九图时，点九图不生效的问题]]></title>
      <url>%2F2016%2F11%2F21%2F201611212239%2F</url>
      <content type="text"><![CDATA[我们都知道点九图的作用，这里就不多说了，反正就是各种好各种美如画，这次我们把点九图用到自定义控件中。我们用 drawBitmap 来绘制点九图，然而似乎有点问题。 我找了这张图来演示一下： 这是用 drawBitmap 的代码： 123Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bubble);Rect rect = new Rect(l, t, r, b);canvas.drawBitmap(bitmap, null, rect, new Paint()); 然后编译运行。 哎呦，我去！这是什么鬼！说好的美如画呢。 没事，我们换两句代码来实现。当绘制点九图时，我们要用到 NinePatch 这个类，代码改成这样： 1234Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bubble);NinePatch ninePatch = new NinePatch(bitmap, bitmap.getNinePatchChunk(), null);RectF rectF = new RectF(l, t, r, b);ninePatch.draw(canvas, rectF); 再运行一次 看，妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义侧边快速索引栏]]></title>
      <url>%2F2016%2F11%2F20%2F201611201107%2F</url>
      <content type="text"><![CDATA[介绍现在有通讯录的项目基本都会用到侧边快速索引栏，网上也有不少第三方开源控件可以使用。但我讲的这个还是稍稍有点不一样的。 和一般索引栏不太一样的地方： 只显示有出现的首字母 出现的索引字母居中显示 代码相对较简单 好吧，编不下去了，其实也没什么不一样的，可以看一下效果图。 思路大致的实现过程如下： 获取要显示的字母 获取需要用到的宽高数值 绘制各个字母 处理 Touch 事件 还是挺简单的，稍稍有点难度的地方应该在计算。 代码自定义控件的实现方法有很多，这里我是用继承 View 来实现的，下面看看具体怎么实现。 获取要显示的字母通过 set 方法获取到要显示的字母集合后,重绘控件：1234public void setIndexs(String[] indexs) &#123; this.indexs = indexs; invalidate();&#125; 获取需要用到的宽高数值绘制侧边栏的时候,我们需要用到以下几个参数来计算字母所在的坐标： 控件的总宽度 mWidth 每个字母可以分配到的高度 mCellHeight 第一个字母和控件顶部的距离 mMarginTop(用于居中显示) 每个字母本身的宽高 当控件的的宽高发生变化时，会执行 onSizeChanged 这个方法，在首次初始化时也会调用，所以前三个参数我们可以在这里获取到。这里考虑最多会出现 27 个字符，如果首字母是数字或者特殊字符，我们用「#」表示。mMarginTop 可能要理解一下，第一个字母距离控件顶部的距离，是控件总高度减去所有字母的总高度的一半，应该不是很难理解： 12345678@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); mCellHeight = (mHeight * 1f / 27); //26个字母加上“#” mMarginTop = (mHeight - mCellHeight * indexs.length) / 2;&#125; 但要说明一下的是，加载控件是需要时间的（处理过 SwipeRefreshLayout 一进去就要转圈的应该理解）。也就是说 onSizeChanged 可能在 setIndexs 之前执行，也可能在它之后执行。这就可能会导致获取不到 mMarginTop，所以我们在 setIndexs 里也加上 mMarginTop = (mHeight - mCellHeight * indexs.length) / 2 这句代码，保证可以拿到这个参数。 至于字母的宽高，不同字母的宽高其实都不一样的，我们可以通过以下方法获取到： 1234567891011public float getTextWidth(String text) &#123; Rect bounds = new Rect(); mPaint.getTextBounds(text, 0, text.length(), bounds); return bounds.width();&#125;public float getTextHeight(String text) &#123; Rect bounds = new Rect(); mPaint.getTextBounds(text, 0, text.length(), bounds); return bounds.height();&#125; 绘制各个字母通过上面获取到的参数，我们可以计算出每个字母的坐标。简单说明一下，使用drawText绘制时使用x坐标是字母最左边的坐标，而 y 坐标是指字母 baseline 的坐标。我们可以简单理解为是字母左下角的坐标。 x 坐标为了让字母在控件里左右居中显示，x 坐标就是控件总宽度的一半减去字母宽度的一半： 1float x = mWidth / 2 - getTextWidth(letter) / 2; y 坐标y 坐标的计算可能要理解一下。首先和宽度类似，让字母在它占有的空间里面上下居中，也就是字母占有高度的一半加上字母高度的一半。然后要加上它前面所有字母的高度，及首字母距离顶部的距离： 1float y = mCellHeight / 2 + getTextHeight(letter) / 2 + mCellHeight * i + mMarginTop; 所以 onDraw 的代码可以这样写： 123456789101112 @Overrideprotected void onDraw(Canvas canvas) &#123; if (indexs.length &lt;= 0) &#123; return; &#125; for (int i = 0; i &lt; indexs.length; i++) &#123; String letter = indexs[i]; float x = mWidth / 2 - getTextWidth(letter) / 2; float y = mCellHeight / 2 + getTextHeight(letter) / 2 + mCellHeight * i + mMarginTop; canvas.drawText(letter, x, y, mPaint); &#125;&#125; 处理Touch事件这个控件的点击和滑动事件做了相同的操作，通过计算当前按下字母的下标来获取到该字母，显示吐司，并且通过回调函数让列表定位。当手指抬起时，把吐司隐藏就好了。 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 按下 case MotionEvent.ACTION_MOVE: // 滑动 // 按下字母的下标 int letterIndex = (int) ((event.getY() - mMarginTop) / mCellHeight); // 判断是否越界 if (letterIndex &gt;= 0 &amp;&amp; letterIndex &lt; indexs.length) &#123; // 显示按下的字母 if (textView != null) &#123; textView.setVisibility(View.VISIBLE); textView.setText(indexs[letterIndex]); &#125; //通过回调方法通知列表定位 if (mOnIndexChangedListener != null) &#123; mOnIndexChangedListener.onIndexChanged(indexs[letterIndex]); &#125; &#125; break; case MotionEvent.ACTION_UP: // 提起 if (textView != null) &#123; textView.setVisibility(View.GONE); &#125; break; &#125; return true;&#125; 到这里，自定义控件就算完成啦。接下来看看它是如何使用的。 使用现在布局里面使用我们的自定义控件，我是这样写的： 12345&lt;com.southernbox.indexbar.widget.IndexBar android:id="@+id/indexbar" android:layout_width="20dp" android:layout_height="match_parent" android:layout_alignParentRight="true" /&gt; 然后就是设置索引字母数组，设置要吐司的 TextView，设置回调方法。在 RecyclerView 中，我们可以使用 LayoutManager 来定位。 123456789101112131415mIndexBar.setIndexs(letters);mIndexBar.setSelectedIndexTextView(tvToast);mIndexBar.setOnIndexChangedListener(new IndexBar.OnIndexChangedListener() &#123; @Override public void onIndexChanged(String index) &#123; for (int i = 0; i &lt; mList.size(); i++) &#123; String firstword = mList.get(i).getFirstword(); if (index.equals(firstword)) &#123; // 滚动列表到指定的位置 layoutManager.scrollToPositionWithOffset(i, 0); return; &#125; &#125; &#125; &#125;); 最后，我们需要写一个方法用来排序，插入索引 item，顺便把要显示的索引字母数组获取到。在 item 的实体类里面，我用 isIndex 这个字段来区分是索引 item，还是普通 item。可以参考一下我的排序方法： 123456789101112131415161718192021222324252627282930313233public Map&lt;String, Object&gt; convertSortList(List&lt;Entity&gt; list) &#123; HashMap&lt;String, List&lt;Entity&gt;&gt; map = new HashMap&lt;&gt;(); for (Entity item : list) &#123; String firstWord; if (TextUtils.isEmpty(item.getFirstWord())) &#123; firstWord = "#"; &#125; else &#123; firstWord = item.getFirstWord().toUpperCase(); &#125; if (map.containsKey(firstWord)) &#123; map.get(firstWord).add(item); &#125; else &#123; List&lt;Entity&gt; mList = new ArrayList&lt;&gt;(); mList.add(item); map.put(firstWord, mList); &#125; &#125; Object[] keys = map.keySet().toArray(); Arrays.sort(keys); List&lt;Entity&gt; sortList = new ArrayList&lt;&gt;(); for (Object key : keys) &#123; Entity t = getIndexItem(key.toString()); sortList.add(t); sortList.addAll(map.get(key)); &#125; HashMap&lt;String, Object&gt; resultMap = new HashMap(); resultMap.put("sortList", sortList); resultMap.put("keys", keys); return resultMap;&#125; 还有一点要说明一下的是，一般情况下侧边索引栏的「#」是放在最后一个的，但是用 Arrays.sort 排序的话会把它放在第一个，要放最后一个的话还要再做一个转换，这里就不再赘述了。 结语这个控件还是比较简单的，这也是一个比较适合用来入门的控件，可能要理解一下的地方在计算方面。个人觉得，如果一个控件不是太复杂的话，最好是自己实现，或者至少要看明白源码。这样一方面可以修改控件适合自己的项目使用，一方面出现了 bug 也可以快速定位修改。妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 ScrollView 嵌套 RecyclerView 时，惯性滑动失效的问题]]></title>
      <url>%2F2016%2F11%2F13%2F201611130905%2F</url>
      <content type="text"><![CDATA[大家知道 ScrollView 是带有惯性滑动效果的。但是在 5.0 以上系统使用 ScrollView 嵌套 RecyleView 时，惯性滑动会失效，滑起来会感觉很不顺畅。那怎么解决呢？ 方法很简单，我们只要让 RecyleView 不可滑动就可以了。RecyleView 是否可左右、上下滑动，是由 LayoutManager 的 canScrollHorizontally 和 canScrollVertically 方法控制的，我们让相应的方法返回 false 就可以了。代码如下： 1234567LinearLayoutManager layoutManager = new LinearLayoutManager(mContext)&#123; @Override public boolean canScrollVertically() &#123; return false; &#125;&#125;;recyclerView.setLayoutManager(layoutManager); 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 Volley 获取网络数据出现乱码]]></title>
      <url>%2F2016%2F11%2F12%2F201611122333%2F</url>
      <content type="text"><![CDATA[刚接触使用 Volley 的时候，发现 Volley 会出现 UTF-8 编码的中文字符串乱码的情况。这里给出一个解决方法。 以 StringRequest 请求为例，其它的类似写一个类继承 StringRequest，然后重写 Response parseNetworkResponse(NetworkResponse response) 方法，将编码指定为 utf-8，代码如下： 12345678910111213141516171819202122public class MyStringRequest extends StringRequest &#123; public MyStringRequest(String url, Response.Listener&lt;String&gt; listener, Response.ErrorListener errorListener) &#123; super(url, listener, errorListener); &#125; /** * 重写以解决乱码问题 */ @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String str = null; try &#123; str = new String(response.data, "utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return Response.success(str, HttpHeaderParser.parseCacheHeaders(response)); &#125;&#125; 使用的时候用我们继承过的 MyStringRequest 类，而不是 StringRequest，问题就解决了。妥妥的。]]></content>
    </entry>

    
  
  
</search>
