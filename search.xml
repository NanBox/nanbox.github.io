<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Anroid Wear OS 手表应用开发 - 微光模式 AmbientMode]]></title>
      <url>%2F2018%2F12%2F17%2F201812171957%2F</url>
      <content type="text"><![CDATA[智能手表的电池容量都比较低，导致续航也比较短。为了延长手表的续航，Wear OS 手表在没有操作一段时间后，会进入微光模式 AmbientMode。 微光模式就是一个省电模式，这个模式会在低功耗下运行，默认情况下，手表会离开当前的应用，返回到表盘的界面。 但有时候，我们希望开发的应用在某些情况下，可以一直保持可见的状态，这就需要我们使用支持微光模式的 Activity 了。 项目配置 build.gradle 配置 添加以下依赖项： 12345dependencies &#123; ... implementation &apos;com.google.android.support:wearable:2.4.0&apos; compileOnly &apos;com.google.android.wearable:wearable:2.4.0&apos;&#125; manifest 配置 添加穿戴设备共享库（仅支持 Android 5.1 及以上版本）： 123456&lt;application&gt; &lt;uses-library android:name=&quot;com.google.android.wearable&quot; android:required=&quot;true&quot; /&gt; ...&lt;/application&gt; 添加保持唤醒权限： 1&lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; 支持微光模式的 Activity修改需要支持微光模式的 Activity，让它继承 WearableActivity，并在 onCreate 中调用 setAmbientEnabled()： 1234567class MainActivity : WearableActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setAmbientEnabled() &#125;&#125; 处理模式切换现在，我们的 Activity 在进入微光模式后，会仍然保持可见。但随着系统功耗的降低，定时器、屏幕刷新率等都会受到影响。 为了用户体验、也为了节省电量，我们需要在进入微光模式的时候做一些处理。 在微光模式下，建议隐藏所有非必要内容，将页面背景换成黑色，字体颜色换成白色。再更进一步，可以停用所有文字的抗锯齿。然后在离开微光模式的时候，恢复成原来的样子。 WearableActivity 的 onEnterAmbient 和 onExitAmbient 方法会在进入和离开微光模式时调用。举个简单的例子，我们可以这样来处理： 123456789101112131415161718192021222324252627/** * 进入微光模式 */override fun onEnterAmbient(ambientDetails: Bundle?) &#123; // 隐藏不重要内容 image_view.visibility = View.GONE // 黑色背景 frame_layout.setBackgroundColor(Color.BLACK) // 白色字体 text_view.setTextColor(Color.WHITE) // 停用抗锯齿 text_view.paint.isAntiAlias = false&#125;/*** 退出微光模式*/override fun onExitAmbient() &#123; // 恢复显示 image_view.visibility = View.VISIBLE // 恢复背景 frame_layout.setBackgroundColor(Color.RED) // 恢复字体 text_view.setTextColor(Color.GREEN) // 启用抗锯齿 text_view.paint.isAntiAlias = true&#125; 频繁更新界面也会一定程度上影响电池续航，官方建议我们在微光模式下，每分钟更新一次界面。WearableActivity 提供了一个方法 onUpdateAmbient() ，它会以每分钟一次的频率回调这个方法： 123456/** * 微光模式下，更新数据 */fun onUpdateAmbient() &#123; refreshData()&#125; 如果界面上有时间显示，可以考虑在正常情况下显示到秒，在微光模式下只显示到分钟。 兼容 FragmentActivity以上就完成了一个 Activity 微光模式的适配，但它有个缺点，必须要继承 WearableActivity。很多时候我们要用到 Fragment，必须要继承 FragmentActivity 才可以。 现在，官方也给出了一种兼容方案，我们继承 FragmentActivity 后实现 AmbientModeSupport.AmbientCallbackProvider 这个接口，在 onCreate 中调用 AmbientModeSupport.attach(this)，像这样： 12345678910111213141516171819class MainActivity : FragmentActivity(), AmbientModeSupport.AmbientCallbackProvider &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) AmbientModeSupport.attach(this) &#125; override fun getAmbientCallback(): AmbientModeSupport.AmbientCallback &#123; return object : AmbientModeSupport.AmbientCallback() &#123; override fun onEnterAmbient(ambientDetails: Bundle) &#123;&#125; override fun onExitAmbient() &#123;&#125; override fun onUpdateAmbient() &#123;&#125; &#125; &#125;&#125; 这样，我们就能在 AmbientCallback 拿到微光模式的相关回调了。 此外，AmbientModeSupport.attach(this) 会返回一个 AmbientController，通过它我们可以主动去获取当前是否处于微光模式。 离开 Activity 时的状态监听当 Activity 退到后台时，上述的几个回调方法将不会再收到回调。 大部分情况下，在 Activity 不可见的时候，我们也不需要监听微光模式做处理，在 Activity 返回前台的时候，必然是退出了微光模式的。 但在某些情况下还是有这样的需求，比如微光模式下要对通知栏做一些特殊处理。这时候只能另辟蹊径获取到回调： 123456789101112131415161718192021val handler = Handler(Looper.getMainLooper())val displayManager = getSystemService(Context.DISPLAY_SERVICE) as DisplayManagerdisplayManager.registerDisplayListener(object : DisplayManager.DisplayListener &#123; override fun onDisplayAdded(displayId: Int) &#123; &#125; override fun onDisplayRemoved(displayId: Int) &#123; &#125; override fun onDisplayChanged(displayId: Int) &#123; if (displayManager.getDisplay(displayId).state == Display.STATE_DOZE) &#123; // 进入微光模式 &#125; else &#123; // 退出微光模式 &#125; &#125;&#125;, handler) 这个方法的本质是监听屏幕进入省电模式。由于进入微光模式伴随着进入屏幕的省电模式，可以认为它们的监听方法是等效的。 实测在返回桌面后，这个方法同样能收到回调。要记得在 onDestroy 里反注册。 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Jetpack - 使用 WorkManager 管理后台任务]]></title>
      <url>%2F2018%2F06%2F30%2F201806301849%2F</url>
      <content type="text"><![CDATA[作为 Android Jetpack 中的新组件，WorkManager 负责用来管理后台任务，它和一个异步任务以及 Service 有什么区别呢？看完你就知道了。 相关类我们先来看看 WorkManager 相关的几个类： Worker任务的执行者，是一个抽象类，需要继承它实现要执行的任务。 WorkRequest指定让哪个 Woker 执行任务，指定执行的环境，执行的顺序等。要使用它的子类 OneTimeWorkRequest 或 PeriodicWorkRequest。 WorkManager管理任务请求和任务队列，发起的 WorkRequest 会进入它的任务队列。 WorkStatus包含有任务的状态和任务的信息，以 LiveData 的形式提供给观察者。 接下来是 WorkManager 的简单使用。 使用WorkManager 的实现包括以下几个步骤。 依赖在 build.gradle 添加如下依赖： 12implementation "android.arch.work:work-runtime:$work_version"implementation "android.arch.work:work-firebase:$work_version" 定义 Worker我们定义 MainWorker 继承 Worker，发现需要重写 doWork 方法，并且需要返回任务的状态 WorkerResult： 123456class MainWorker : Worker() &#123; override fun doWork(): WorkerResult &#123; // 要执行的任务 return WorkerResult.SUCCESS &#125;&#125; 我们暂时什么都不做，直接返回任务执行完成 WorkerResult.SUCCESS。 定义 WorkRequest在 MainActivity 中定义 WorkRequest： 1val request = OneTimeWorkRequest.Builder(MainWorker::class.java).build() OneTimeWorkRequest 意味着这个任务只需执行一遍。 加入任务队列要让任务执行，需要将 WorkRequest 加入任务队列： 1WorkManager.getInstance().enqueue(request) 现在加入任务队列后，任务会马上得到执行。但需要注意的是，这句代码的作用是将任务加入任务队列，而不是执行任务，至于区别后面会讲到。 数据交互后台任务少不了数据的交互，我们看一下数据是如何传入传出的。 input先是在 Activity 传数据给 Worker ，我们传一个格式化过的时间过去： 123456789val dateFormat = SimpleDateFormat(&quot;hh:mm:ss&quot;, Locale.getDefault())val data = Data.Builder() .putString(&quot;time&quot;, dateFormat.format(Date())) .build()val request = OneTimeWorkRequest.Builder(DemoWorker::class.java) .setInputData(data) .build() 使用 WorkRequest 的 setInputData 方法传递 Data，Data 的使用和 Bundle 差不多。 在 Worker 中，从 inputData 可以取到数据，这里取到后简单打印一下： 123456class MainWorker : Worker() &#123; override fun doWork(): WorkerResult &#123; Log.d(&quot;WorkManager&quot;, inputData.getString(&quot;time&quot;,&quot;&quot;)) return WorkerResult.SUCCESS &#125;&#125; output当任务处理完了，需要将处理结果返回。传入的是 inputData，传出就是 outputData： 123456789class MainWorker : Worker() &#123; override fun doWork(): WorkerResult &#123; Log.d(&quot;MainWorker&quot;, inputData.getString(&quot;time&quot;,&quot;&quot;)) outputData = Data.Builder() .putString(&quot;name&quot;, &quot;SouthernBox&quot;) .build() return WorkerResult.SUCCESS &#125;&#125; 每一个 WorkRequest 都会有一个 id，通过 id 可以获取到对应任务的 WorkStatus，并且是以 LiveData 形式提供的： 1234567WorkManager.getInstance() .getStatusById(request.id) .observe(this, Observer &#123; workStatus -&gt; if (workStatus != null &amp;&amp; workStatus.state.isFinished) &#123; Log.d(&quot;MainActivity&quot;, workStatus.outputData.getString(&quot;name&quot;, &quot;&quot;)) &#125; &#125;) 如果需要取消一个在队列中的任务，也是通过 id 实现的： 1WorkManager.getInstance().cancelWorkById(request.id) 这样我们就完成了一个最简单的 WorkManager，执行一下就可以看到打印的结果了。 特性到目前为止都是基本操作，和一个普通的异步任务没有太大区别，接下来我们看看它不一样的一些地方。 环境约束WorkManager 允许我们指定任务执行的环境，比如网络已连接、电量充足时等，在满足条件的情况下任务才会执行。 可指定的条件及设置方法如下： 1234567891011val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) // 网络状态 .setRequiresBatteryNotLow(true) // 不在电量不足时执行 .setRequiresCharging(true) // 在充电时执行 .setRequiresStorageNotLow(true) // 不在存储容量不足时执行 .setRequiresDeviceIdle(true) // 在待机状态下执行，需要 API 23 .build()val request = OneTimeWorkRequest.Builder(MainWorker::class.java) .setConstraints(constraints) .build() 这个很好理解，除了网络状态，其他设置项都是传入一个布尔值，网络状态可选值如下: 状态 说明 NOT_REQUIRED 没有要求 CONNECTED 网络连接 UNMETERED 连接无限流量的网络 METERED 连接按流量计费的网络 NOT_ROAMING 连接非漫游网络 我们试一下效果，添加一个需要联网的条件，Activity 代码如下: 12345678910111213141516171819202122232425262728293031323334class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val constraints = Constraints.Builder() .setRequiredNetworkType(NetworkType.CONNECTED) .build() val dateFormat = SimpleDateFormat(&quot;hh:mm:ss&quot;, Locale.getDefault()) val data = Data.Builder() .putString(&quot;date&quot;, dateFormat.format(Date())) .build() val request = OneTimeWorkRequest .Builder(MainWorker::class.java) .setConstraints(constraints) .setInputData(data) .build() WorkManager.getInstance().enqueue(request) WorkManager.getInstance() .getStatusById(request.id) .observe(this, Observer&lt;WorkStatus&gt; &#123; workStatus -&gt; if (workStatus != null &amp;&amp; workStatus.state.isFinished) &#123; Log.d(&quot;MainActivity&quot;, workStatus.outputData.getString(&quot;name&quot;, &quot;&quot;)) &#125; &#125;) &#125;&#125; 打开应用之前，先把网络关闭，打开后发现 Worker 并没有打印时间，这时候再把网连上，就会看到打印出时间了。 这也是为什么前面说 WorkManager.getInstance().enqueue(request) 是将任务加入任务队列，并不代表马上执行任务，因为任务可能需要等到满足环境条件的情况才会执行。 强大的生命力还是一样的代码，我们来做点不一样的操作： 断网后运行 将进程杀掉 联网 再次运行 不出意外的话，这时候你会看到有两个时间的打印，而且两个时间还不一样，这是为什么呢？ 第一个时间是第一次运行后，加入了任务队列，但还没有执行的任务。第二个则是本次执行的任务打印的。这说明了，就算进程被杀掉，任务还是存在，甚至如果重启手机，任务依然会在满足条件的情况下得到执行。 这是 WorkManager 的另一个特点，一旦发起一个任务，任务是可以保证一定会被执行的，就算退出应用，甚至重启手机都阻止不了他。但可能由于添加了环境约束等原因，它执行的时间是不确定的。 当应用正在运行时，它会在当前的进程中启用一个子线程执行。应用没有运行的情况下启用，它则会自己选择一种合适的方式在后台运行。具体是什么方式和 Android 的版本和依赖环境有关： 定时任务前面说了 OneTimeWorkRequest 是指任务只需要执行一遍，而 PeriodicWorkRequest 则可以发起一个多次执行的定时任务： 12345val request = PeriodicWorkRequest .Builder(MainWorker::class.java, 15, TimeUnit.MINUTES) .setConstraints(constraints) .setInputData(data) .build() 这样，发起的任务就会每隔 15 分钟执行一次。除了需要传入间隔时间，使用起来跟 OneTimeWorkRequest 是没有区别的。 你可能会想更频繁的去执行一个任务，比如几秒钟执行一遍，但很遗憾，最小时间间隔就是 15 分钟，看一下源码就知道了。 还有需要注意的是，定时任务并不是说经过指定时间后它就马上执行，而是经过这一段时间后，等到满足约束条件等情况时，它才执行。 任务链WorkManager 允许我们按照一定的顺序执行任务，比如我想 A、B、C 三个任务按先后顺序执行： 可以这样写，把它们组成一条任务链： 12345WorkManager.getInstance() .beginWith(workA) .then(workB) .then(workC) .enqueue() 这样的话，上一个任务的 outputData 会成为下一个任务的 inputData。 再更复杂一点，我想 A 和 B 同时执行，它们都执行完之后，再执行 C： 也是可以实现的： 1234WorkManager.getInstance() .beginWith(workA,workB) .then(workC) .enqueue() 再更更复杂一点，如果我想这样： 这样就需要先把 A、B 和 C、D 分别组成一条任务链，再进行联结： 12345678910val chain1 = WorkManager.getInstance() .beginWith(workA) .then(workB)val chain2 = WorkManager.getInstance() .beginWith(workC) .then(workD)val chain3 = WorkContinuation .combine(chain1, chain2) .then(workE)chain3.enqueue() 再更更更复杂一点，如果我把定时任务放进去会怎样？不好意思，链式任务只支持 OneTimeWorkRequest。 使用任务链，我们可以将各种任务进行模块化。同样的，任务链不保证每个任务执行的时间，但是保证它们执行的先后顺序。 任务唯一性很多情况下，我们希望在任务队列里，同一个任务只存在一个，避免任务的重复执行，这时候可以用到 beginUniqueWork 这个方法： 123WorkManager.getInstance() .beginUniqueWork(&quot;unique&quot;, ExistingWorkPolicy.REPLACE, request) .enqueue() 需要传入一个任务的标签，和重复任务的执行方式，可取值如下： 状态 说明 REPLACE 删除已有的任务，添加现有的任务 KEEP 什么都不做，不添加新任务，让已有的继续执行 APPEND 加入已有任务的任务链最末端 但这种方式也是只支持 OneTimeWorkRequest。如果是 PeriodicWorkRequest，我想到的办法是每次执行之前，根据标签去取消已有的任务。 以上，就是本文对 WorkManager 的简单介绍和用法讲解。 保活?这里引入一个思考，既然 WorkManager 的生命力这么强，还可以实现定时任务，那能不能让我们的应用生命力也这么强？换句话说，能不能用它来保活? 要是上面有细看的话，你应该已经发现这几点了： 定时任务有最小间隔时间的限制，是 15 分钟 只有程序运行时，任务才会得到执行 无法拉起 Activity 总之，用 WorkManager 保活是不可能了，这辈子都不可能保活了。 使用场景？很明显，WorkManager 区别于异步任务，它更像是一个 Service。基本上，WorkManager 能做的，Service 也能做，我并没有想到有什么情况是非用 WorkManger 不可的。 但反观 Service，泛滥的 Service 后台任务可能是引起 Android 系统卡顿的主要原因，这几年 Google 也对 Service 也做了一些限制。 对 Service 的限制Android 6.0 (API 23) 休眠模式：在关闭手机屏幕后，系统会禁止应用的网络请求等功能。 Android 8.0（API 26） 在某些不被允许的情况下，调用 startService 会抛异常。 但目前很多 APP 的 target API 还在 23 以下，因为不想处理运行时权限，更别说 API 26 了。基于此，2017 年年底，谷歌采取了少有的强硬措施。 对 Target API 的要求2018 年 8 月起 所有新开发的应用，Target API 必须是 26 或以上。 2018 年 11 月起 所有已发布的应用，Target API 必须更新到 26 或以上。 2019 年起 每次发布新版本后，所有应用都必须在一年内将 Target API 更新到最新版本 虽然这些措施对国内的环境没有办法造成直接影响，但这也会成为一种发展指导方向。 更合理的后台任务管理说了这么多，我想表达的是，在不久的将来，在某些情况下，Service 已经没卵用了！ 而 WorkManager 作为一个更合理的后台任务管理库，在这种情况下就是一个更好的选择了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Jetpack - 使用 Navigation 管理页面跳转]]></title>
      <url>%2F2018%2F06%2F07%2F201806072042%2F</url>
      <content type="text"><![CDATA[在今年的 IO 大会上，发布了一套叫 Android Jetpack 的程序库。Android Jetpack 里的组件大部分我们都接触过了，其中也有一些全新的组件，其中一个就是 Navigation。 简介Navigation 是用来管理 APP 里页面跳转的。起初，我以为它是用来代替 startActivity 的，但其实并不是，大家往下看就知道它的作用了。 另外，iOS 的同学可能会有似曾相识的感觉，Navigation 应该是有借鉴 Storyboard 的。 使用我们先来看看 Navigation 的实现过程。 添加依赖首先，需要使用 Android Studio 3.2 以上版本才能使用 Navigation。 在 build.gradle 中添加依赖： 12implementation "android.arch.navigation:navigation-fragment:$nav_version"implementation "android.arch.navigation:navigation-ui:$nav_version" 创建 navigation xml 文件使用 「Android Resource File」创建 xml 文件的时候，可以看到在类型里，多了一个 Navigation 的选项： 创建成功后，就来到了文章开头的那个一个可视化的操作界面。点击左上角的添加小图标，会出现 Activity 和 Fragment，我们这里添加两个 Activity 和两个 Fragment： 配置 ActionFragment 的右边有个小圆圈，点击并拖到另一个页面，这样我们就给这个 Fragment 添加了一个跳转行为，也就是 Action。 但是可以发现，Activity 的右边是没有这个小圆圈的，所以 Navigation 并不能处理从 Activity 发起的跳转。 左上角有个小房子的是显示的第一个页面，但由于 Activity 无法发起跳转，所以这里把 MainActivity 删除，把 MainFragment 作为主页面，并给它添加跳转到 SecondFragment 和 SecondActivity 的 Action： 自动生成的 xml 代码是这样的： 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;navigation xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" app:startDestination="@id/mainFragment"&gt; &lt;fragment android:id="@+id/mainFragment" android:name="com.example.navigation.MainFragment" android:label="fragment_main" tools:layout="@layout/fragment_main"&gt; &lt;action android:id="@+id/action_mainFragment_to_secondFragment" app:destination="@id/secondFragment" app:enterAnim="@anim/slide_in_right" /&gt; &lt;action android:id="@+id/action_mainFragment_to_secondActivity" app:destination="@id/secondActivity" /&gt; &lt;/fragment&gt; &lt;fragment android:id="@+id/secondFragment" android:name="com.example.navigation.SecondFragment" android:label="fragment_second" tools:layout="@layout/fragment_second" /&gt; &lt;activity android:id="@+id/secondActivity" android:name="com.example.navigation.SecondActivity" android:label="activity_second" tools:layout="@layout/activity_second" /&gt;&lt;/navigation&gt; 布局中添加 Fragment现在，我们第一个页面是 MainFragment，而 Fragment 需要 Activity 作为容器，修改 MainActivity 的布局： 123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/fragment" android:name="androidx.navigation.fragment.NavHostFragment" android:layout_width="match_parent" android:layout_height="match_parent" app:defaultNavHost="true" app:navGraph="@navigation/nav" /&gt;&lt;/FrameLayout&gt; 其中有三个属性需要注意。使用 android:name 指定 Fragment 的类型为 NavHostFragment，使用 app:navGraph 指定 Navigation 文件。app:defaultNavHost=”true” 的作用是，让 Navigation 处理返回事件，点返回按钮时并不是返回上一个 Activity，而是返回上一个「页面」，上一个「页面」有可能是 Activity，也可能是 Fragment。 至此，Navigation 的简单配置就算完成了，接下来看如何使用它。 配置跳转在 Navigation 里，页面的跳转是交给 NavController 来处理的，获取 NavController 的方法有这么三种： 123NavHostFragment.findNavController(Fragment)Navigation.findNavController(Activity, @IdRes int viewId)Navigation.findNavController(View) 拿到后，通过 navigate 方法，通过传入 Action 的 id，实现跳转，比如： 123NavHostFragment .findNavController(this) .navigate(R.id.action_firstFragment_to_secondFragment) 在简单配置了两个跳转后，看一下目前的效果： 传参页面的跳转少不了数据的传递，使用 Navigation，和我们原来的跳转一样，可以通过 Bundle 来传递参数： 12345val bundle = Bundle()bundle.putString("name", "SouthernBox")NavHostFragment .findNavController(this) .navigate(R.id.action_firstFragment_to_secondFragment, bundle) 如果跳转到 Activity，可以从 intent.extras 获取到 bundle，如果是 Fragment，则从 arguments 获取到。 此外，还可以在 Navigation 的 xml 文件中配置传参，但这种方式目前支持的数据类型比较少，连 boolean 都不支持，而且我还碰到了 bug，所以目前不建议用。 转场动画如果需要自定义的页面转场动画，使用 Navigation 可以很方便的实现。 这里举个例子，比如我们需要一个从右向左切入的过场动画，先创建这个动画的 xml 文件： 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="600" android:fromXDelta="100%" android:toXDelta="0" /&gt;&lt;/set&gt; 然后我们回到 Navigation 的可视化编辑页面来，点击跳转的线，右边会出现过场动画的配置选项，将 xxxx 设为刚才创建的动画： 这么简单就搞定了，效果如下： Navigation 的使用介绍就到这里。 思考你可能已经明白，Navigation 主要是用来处理 Fragment 的跳转，所以说它并不是用来代替 startActivity，而是用来代替 FragmentTransaction 的相关操作。 在官方文档里，可以看到一个将传统跳转迁移到 Navigation 的建议。我简单理解为，将原本两个 Activity 之间的跳转，逐渐修改为使用一个 Activity 作为容器，用两个 Fragment 作为页面跳转。 看到这里，我联想到了在去年，Jake Worton（目前在谷歌）有这么一个有争议的言论： “一个 APP 只需要一个 Activity。” 在过去，要实现这种方式，就需要去解决复杂的 Fragment 堆栈处理，而且早期的 Fragment 坑比较多，处理不好容易出现页面穿透等问题。现在 Navigation 恰好解决了这些问题。 这一切联系起来，是不是能说明官方间接支持了「少用 Activity 多用 Fragment」的做法？你怎么看？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义 Behavior，实现嵌套滑动、平滑切换周月视图的日历]]></title>
      <url>%2F2018%2F03%2F27%2F201803271206%2F</url>
      <content type="text"><![CDATA[使用 CoordinateLayout 可以协调它的子布局，实现滑动效果的联动，它的滑动效果由 Behavior 实现。以前用过小米日历，对它滑动平滑切换日月视图的效果印象深刻。本文尝试用自定义 Behavior 实现一个带有这种效果的日历。 简介先上个小米日历的图，让大家知道要做一个什么效果： 这是小米日历的效果，在用户操作列表的时候，将日历折叠成周视图，扩大列表的显示区域，同时也不影响日历部分的功能使用，有趣且实用。 下面利用 CoordinateLayout.Behavior，简单实现一个类似的效果。 日历控件我并不打算自己再写一个日历控件。原本想用原生的 CalendarView，但是 CalendarView 不支持周视图，可自定义程度也不高。 在 GitHub 搜了一下，决定使用 MaterialCalendarView。这个库比较流行，它支持周月视图的切换，符合 Material Design，也可以自定义显示效果。 引入该库，在布局文件中使用： 12345&lt;com.prolificinteractive.materialcalendarview.MaterialCalendarView android:id="@+id/calendar" android:layout_width="match_parent" android:layout_height="wrap_content" app:mcv_showOtherDates="all" /&gt; 切换视图代码如下： 123calendarView.state().edit() .setCalendarDisplayMode(CalendarMode.WEEKS) .commit(); Behavior写代码之前，还有些东西需要先了解一下。 用 CoordinatorLayout 作为根布局，就可以协调它子控件之间的联动效果，至于如何联动，是由它的内部类 Behavior 实现的。在布局中，对子控件配置 app:layout_behavior 属性，实现对应的联动效果。所以这里我们需要自定义日历和列表的两个 Behavior。 Behavior 有两种实现联动的方式。一种是通过建立依赖关系，一种是通过 RecyclerView 或 NextedScrollView 的嵌套滑动机制，后面都会讲到。我们要先分析想要实现的效果，确定各个子控件之间的依赖关系，避免循环依赖等错误。 另外，由于 CoordinatorLayout 的布局类似于 FrameLayout，所以还需要考虑摆放控件位置的问题。 折叠效果大家可能有看过 RecyclerView 和 AppBarLayout 联动的效果，这种效果需要给 RecyclerView 配置 Behavior： 1app:layout_behavior="@string/appbar_scrolling_view_behavior" 但为什么只要给 RecyclerView 配不用给 AppBarLayout 配？看一下 AppBarLayout 的源码就知道了，它默认已经给自己配了： 1234@CoordinatorLayout.DefaultBehavior(AppBarLayout.Behavior.class)public class AppBarLayout extends LinearLayout &#123; // ...&#125; 看它 Behavior 源码发现，它继承了 ViewOffsetBehavior。ViewOffsetBehavior 的作用是方便改变控件的位置和获取偏移量。所以这里我再偷个懒，把源码里的 ViewOffsetBehavior 直接拷出来用了。 我们自定义两个 Behavior，列表控件的 CalendarScrollBehavior 和日历控件的 CalendarBehavior，都继承 ViewOffsetBehavior。 CalendarScrollBehavior在 Behavior 中，通过 layoutDependsOn 方法来建立依赖关系，一个控件可以依赖多个其他控件，但不可循环依赖。当被依赖的控件属性发生变化时，会调用 onDependentViewChanged 方法。 为了降低复杂程度，我将所有折叠操作都放到 CalendarBehavior 里做，而 CalendarScrollBehavior 里面做一件事，就是把列表置于日历之下。参考了源码 ScrollingViewBehavior，CalendarScrollBehavior 代码如下： 1234567891011121314151617181920212223242526272829public class CalendarScrollBehavior extends ViewOffsetBehavior&lt;RecyclerView&gt; &#123; private int calendarHeight; public CalendarScrollBehavior(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, RecyclerView child, View dependency) &#123; return dependency instanceof MaterialCalendarView; &#125; @Override protected void layoutChild(CoordinatorLayout parent, RecyclerView child, int layoutDirection) &#123; super.layoutChild(parent, child, layoutDirection); if (calendarHeight == 0) &#123; final List&lt;View&gt; dependencies = parent.getDependencies(child); for (int i = 0, z = dependencies.size(); i &lt; z; i++) &#123; View view = dependencies.get(i); if (view instanceof MaterialCalendarView) &#123; calendarHeight = view.getMeasuredHeight(); &#125; &#125; &#125; child.setTop(calendarHeight); child.setBottom(child.getBottom() + calendarHeight); &#125;&#125; 这里没有用到 onDependentViewChanged 方法，所有联动操作都将通过嵌套滑动机制实现。 CalendarBehavior接下来是本文的重点，我们使用的嵌套滑动机制，主要涉及到以下几个方法： onStartNestedScroll onNestedPreScroll onStopNestedScroll onNestedPreFling 当 RecyclerView 或 NestedScrollView 滑动时，CoordinatorLayout 的子控件 Behavior 可以接收到对应的回调。看方法名应该大概知道它的用途了，下面都会提到。 onStartNestedScroll 的返回值决定是否接收嵌套滑动事件。我们判断，只要是上下滑动，就接收： 12345678@Overridepublic boolean onStartNestedScroll(CoordinatorLayout coordinatorLayout, MaterialCalendarView child, View directTargetChild, View target, int axes, int type) &#123; return (axes &amp; ViewCompat.SCROLL_AXIS_VERTICAL) != 0;&#125; onNestedPreScroll 这个方法是在准备滚动之前调用的，它带有滚动偏移量 dy。 1234567@Overridepublic void onNestedPreScroll(CoordinatorLayout coordinatorLayout, final MaterialCalendarView child, View target, int dx, int dy, int[] consumed, int type) 我们要做的，就是在恰当的时候，消费掉这个偏移量，转化成折叠的效果。 分析一下这个折叠效果。滚动时，日历也向上滚动，最多到当前选中日期那一行，滚动范围和当前选中日期有关。向上移动是负值，所以日历的滚动范围是从 0 到 -calendarLineHeight (weekOfMonth - 1)，减 1 是因为要多留一行显示星期的标题。列表的滚动范围则是固定的，最多向上移动 5 倍的日历行高，也就是从 0 到 -calendarLineHeight 5。 判断偏移量是否在这个范围内，用 ViewOffsetBehavior 的 setTopAndBottomOffset 方法来改变控件位置。所以还要拿到 CalendarScrollBehavior 进行操作。参数 target 是触发嵌套滑动的控件，在这里就是 RecyclerView，通过 target.getLayoutParams()).getBehavior() 就可以拿到 CalendarScrollBehavior 了。 折叠过程中，要将偏移量消费掉，这就用到了 consumed 这个参数，它是一个长度为 2 的数组，存放的是要消费掉的 x 和 y 轴偏移量。 最终代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940@Overridepublic void onNestedPreScroll(CoordinatorLayout coordinatorLayout, final MaterialCalendarView child, View target, int dx, int dy, int[] consumed, int type) &#123; // 列表未滑动到顶部时，不处理 if (target.canScrollVertically(-1)) &#123; return; &#125; // 切换月视图 setMonthMode(child); if (calendarMode == CalendarMode.MONTHS) &#123; if (calendarLineHeight == 0) &#123; calendarLineHeight = child.getMeasuredHeight() / 7; weekCalendarHeight = calendarLineHeight * 2; monthCalendarHeight = calendarLineHeight * 7; listMaxOffset = calendarLineHeight * 5; &#125; // 移动日历 int calendarMinOffset = -calendarLineHeight * (weekOfMonth - 1); int calendarOffset = MathUtils.clamp( getTopAndBottomOffset() - dy, calendarMinOffset, 0); setTopAndBottomOffset(calendarOffset); // 移动列表 final CoordinatorLayout.Behavior behavior = ((CoordinatorLayout.LayoutParams) target.getLayoutParams()).getBehavior(); if (behavior instanceof CalendarScrollBehavior) &#123; final CalendarScrollBehavior listBehavior = (CalendarScrollBehavior) behavior; int listMinOffset = -listMaxOffset; int listOffset = MathUtils.clamp( listBehavior.getTopAndBottomOffset() - dy, -listMaxOffset, 0); listBehavior.setTopAndBottomOffset(listOffset); if (listOffset &gt; -listMaxOffset &amp;&amp; listOffset &lt; 0) &#123; consumed[1] = dy; &#125; &#125; &#125;&#125; 现在我们可以把布局参数配一下，看一下效果了，布局如下： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.prolificinteractive.materialcalendarview.MaterialCalendarView android:id="@+id/calendar" android:layout_width="match_parent" android:layout_height="wrap_content" app:layout_behavior="@string/calendar_behavior" app:mcv_showOtherDates="all" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginBottom="110dp" android:background="@color/color_ee" app:layout_behavior="@string/calendar_scrolling_behavior" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 在选中其他日期的时候，记得通知 Behvior 选中的是该月的第几个星期： 123456789calendarView.setOnDateChangedListener(new OnDateSelectedListener() &#123; @Override public void onDateSelected(MaterialCalendarView widget, CalendarDay date, boolean selected) &#123; Calendar calendar = date.getCalendar(); calendarBehavior.setWeekOfMonth(calendar.get(Calendar.WEEK_OF_MONTH)); &#125;&#125;); 效果如下： 星期标题上面效果可以看到，显示星期的标题也一起向上移动了，而且 MaterialCalendarView 是没办法隐藏这个标题的。 没办法，只好自己写一个星期标题的控件盖在上面，简单写了一个 WeekTitleView，代码就不贴了，在布局里加上： 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;com.prolificinteractive.materialcalendarview.MaterialCalendarView android:id="@+id/calendar" android:layout_width="match_parent" android:layout_height="wrap_content" app:layout_behavior="@string/calendar_behavior" app:mcv_showOtherDates="all" /&gt; &lt;android.support.v7.widget.RecyclerView android:id="@+id/recycler_view" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_marginBottom="110dp" android:background="@color/color_ee" app:layout_behavior="@string/calendar_scrolling_behavior" tools:listitem="@layout/item_list" /&gt; &lt;com.southernbox.nestedcalendar.view.WeekTitleView android:layout_width="match_parent" android:layout_height="wrap_content" android:background="#fafafa" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 效果如下： 平滑切换视图接下来处理周月视图切换的问题。 当嵌套滑动结束时会回调 onStopNestedScroll 方法，可以在这里根据当前控件的位置，判断是否要切换视图。当滑动到最上面的时候切换为周视图，其余的情况都是月视图： 1234567891011121314@Overridepublic void onStopNestedScroll(final CoordinatorLayout coordinatorLayout, final MaterialCalendarView child, final View target, int type) &#123; if (calendarLineHeight == 0) &#123; return; &#125; if (target.getTop() == weekCalendarHeight) &#123; setWeekMode(child); &#125; else &#123; setMonthMode(child); &#125;&#125; 效果如下： MaterialCalendarView 的视图切换会有一点点卡顿，但还是能接受的。 惯性滑动上面效果可以看出一个问题，当滑动到一半的时候松手，应该要恢复到完整视图的位置。这里包含了，快速滑动后惯性滑动到指定位置的效果，和没有快速滑动时，往就近的指定位置滑动这两种效果。 我们可以从 onNestedPreFling 拿到滑动速度，方法的返回值决定了是否进行惯性嵌套滑动： 123456789@Overridepublic boolean onNestedPreFling(CoordinatorLayout coordinatorLayout, MaterialCalendarView child, View target, float velocityX, float velocityY) &#123; this.velocityY = velocityY; return !(target.getTop() == weekCalendarHeight || target.getTop() == monthCalendarHeight);&#125; 在 onStopNestedScroll 里判断并执行滚动。由于我们的滚动折叠效果是在 onNestedPreScroll 实现的，所以要想办法触发这个方法。通过源码可以知道，onNestedPreScroll 是在 dispatchNestedPreScroll 里调用的，前提是 startNestedScroll 为 true。所以可以这样触发： 12recyclerView.startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH);recyclerView.dispatchNestedPreScroll(0, dy, new int[2], new int[2], TYPE_TOUCH); 最终 onStopNestedScroll 的完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Overridepublic void onStopNestedScroll(final CoordinatorLayout coordinatorLayout, final MaterialCalendarView child, final View target, int type) &#123; if (calendarLineHeight == 0) &#123; return; &#125; if (target.getTop() == weekCalendarHeight) &#123; setWeekMode(child); return; &#125; else if (target.getTop() == monthCalendarHeight) &#123; setMonthMode(child); return; &#125; if (!canAutoScroll) &#123; return; &#125; if (calendarMode == CalendarMode.MONTHS) &#123; final Scroller scroller = new Scroller(coordinatorLayout.getContext()); int offset; int duration = 800; if (Math.abs(velocityY) &lt; 1000) &#123; if (target.getTop() &gt; calendarLineHeight * 4) &#123; offset = monthCalendarHeight - target.getTop(); &#125; else &#123; offset = weekCalendarHeight - target.getTop(); &#125; &#125; else &#123; if (velocityY &gt; 0) &#123; offset = weekCalendarHeight - target.getTop(); &#125; else &#123; offset = monthCalendarHeight - target.getTop(); &#125; &#125; velocityY = 0; duration = duration * Math.abs(offset) / (listMaxOffset); scroller.startScroll( 0, target.getTop(), 0, offset, duration); ViewCompat.postOnAnimation(child, new Runnable() &#123; @Override public void run() &#123; if (scroller.computeScrollOffset() &amp;&amp; target instanceof RecyclerView) &#123; canAutoScroll = false; RecyclerView recyclerView = (RecyclerView) target; int delta = target.getTop() - scroller.getCurrY(); recyclerView.startNestedScroll(ViewCompat.SCROLL_AXIS_VERTICAL, TYPE_TOUCH); recyclerView.dispatchNestedPreScroll( 0, delta, new int[2], new int[2], TYPE_TOUCH); ViewCompat.postOnAnimation(child, this); &#125; else &#123; canAutoScroll = true; if (target.getTop() == weekCalendarHeight) &#123; setWeekMode(child); &#125; else if (target.getTop() == monthCalendarHeight) &#123; setMonthMode(child); &#125; &#125; &#125; &#125;); &#125;&#125; 到这里，自定义 Behavior 就算完成了。 效果看一下最终的效果： 这种实现方式的优点是代码量少，用起来方便。使用了 MaterialCalendarView 并且没有修改它的源码，意味着支持它的所有功能。 希望通过本文，大家对 Behavior 有一个大概的了解。 项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[打造自己的 APP「冰与火百科」（四）：WebView 交互、夜间模式]]></title>
      <url>%2F2017%2F12%2F25%2F201712251212%2F</url>
      <content type="text"><![CDATA[给大家介绍一下简单的 WebView 交互和夜间模式在「冰与火百科」中的实现。 WebView 交互在详情页面我是用 WebView 展示的，我想实现的交互是，点击 WebView 的内容跳转另一个页面。实现过程是，让 HTML 代码调用 JavaScript 代码，再让 JavaScript 代码调用 Android 的代码，下面看看如何实现。 HTML先看 HTML 代码，假如在文本内容里有一个可以跳转的「凯特琳·徒利」，让他去调用 skip.js 的代码，指定 CatelynTully() 方法： 1234&lt;body&gt; &lt;a href="javascript:void(0)" onclick="CatelynTully()"&gt;凯特琳·徒利&lt;/a&gt; &lt;script type="text/javascript" src="skip.js"&gt;&lt;/script&gt;&lt;/body&gt; JavaScript这个 skip.js 文件我是放在客户端的，放在 assets 目录下，代码如下： 123function CatelynTully()&#123; javascript:Android.goDetail('Catelyn_Tully');&#125; 意思就是去调用 Android 的 goDetail(String id) 方法。 Android在客户端添加 goDetail 方法，我把 JavaScript 和 Java 交互的代码写在一个类里，记得给方法加上 @JavascriptInterface 注解： 12345678910111213public class Js2Java &#123; private Context mContext; public Js2Java(Context context) &#123; this.mContext = context; &#125; @JavascriptInterface public void goDetail(String id) &#123; // 根据 id 跳转页面 &#125;&#125; 来到显示 WebView 的页面，添加以下代码让 WebView 支持 JavaScript： 12webView.getSettings().setJavaScriptEnabled(true);webView.addJavascriptInterface(new Js2Java(this), "Android"); 使用 loadDataWithBaseURL 来展示数据： 1binding.webView.loadDataWithBaseURL("file:///android_asset/", htmlData, "text/html", "utf-8", null); 这样就完成了一个简单的 JavaScript 和 Android 的交互，效果如下： 夜间模式关于夜间模式的实现，主要是参考了 D_clock爱吃葱花 大神的这篇文章，简单说一下实现过程如下： 在 styles 中添加「DayTheme」和「NightTheme」两个主题； 在布局文件中使用类似 android:background=”?attr/colorBackground” 来设置颜色，使其跟随当前主题颜色； 编写 DayNightHelper，利用 SharePreferences 保存、获取当前模式； 在页面 setContentView 之前，判断当前模式，并通过 setTheme 设置当前模式； 将屏幕内容转为 Bitmap，对其执行一个渐隐动画，实现切换时渐变的效果； 监听模式切换，通过 TypedValue 和 Theme.resolveAttribute 在代码中获取 Theme 中的颜色，重新设置控件的颜色。 更详细的内容可以查看原文，下面再补充几个控件的颜色设置方法。 Toolbar假设已经拿到了切换后的颜色 color，修改 Toolbar 的背景颜色和字体颜色： 12toolbar.setBackground(color);toolbar.setTitleTextColor(color); 除了这两项，Toolbar 上可能还有操作按钮，像我这里左边的菜单和右边的搜索按钮。它们的颜色可以这样设置： 1234567891011// 菜单按钮Drawable navigationIcon = toolbar.getNavigationIcon();if (navigationIcon != null) &#123; navigationIcon.setColorFilter(color, PorterDuff.Mode.SRC_ATOP);&#125;// 搜索按钮Menu toolbarMenu = toolbar.getMenu();Drawable searchIcon = toolbarMenu.getItem(0).getIcon();if (searchIcon != null) &#123; searchIcon.setColorFilter(color, PorterDuff.Mode.SRC_ATOP);&#125; TabLayout对于 TabLayout，涉及到的颜色有背景颜色、文字颜色（选中和未选中）、指示条： 123tabLayout.setBackgroundResource(color);tabLayout.setTabTextColors(normalColor, selectedColor);tabLayout.setSelectedTabIndicatorColor(color); NavigationViewNavigationView 存在一个头部，需要的话可以可以这样修改头部的背景和字体颜色： 12345678View navigationHeader = navigationView.getHeaderView(0);if (isDay) &#123; navigationHeader.setBackgroundResource(R.drawable.side_nav_bar_day);&#125; else &#123; navigationHeader.setBackgroundResource(R.drawable.side_nav_bar_night);&#125;TextView tvHeader = (TextView) navigationHeader.findViewById(R.id.text_view);tvHeader.setTextColor(color); 接下来是目录部分的背景、字体颜色及图表颜色： 123navigationView.setBackgroundResource(color);navigationView.setItemTextColor(color);navigationView.setItemIconTintList(color); RecyclerView通过遍历所有的 ChildView，对每一项进行颜色设置： 1234for (int position = 0; position &lt; recyclerView.getChildCount(); position++) &#123; ViewGroup childView = (ViewGroup) binding.recyclerView.getChildAt(position); // 设置颜色&#125; 但要注意的是，RecyclerView 的内部使用 Recycler 和 RecyclerViewPool 实现了缓存，有可能出现当前使用的 item 颜色改变了，但是缓存里的没有变化。 解决方法是清理缓存，调用 Recycler 和 RecyclerViewPool 的 Clear() 方法，但前者无法直接调用，只能通过反射实现： 123456789101112Class&lt;RecyclerView&gt; recyclerViewClass = RecyclerView.class;try &#123; Field declaredField = recyclerViewClass.getDeclaredField("mRecycler"); declaredField.setAccessible(true); Method declaredMethod = Class.forName(RecyclerView.Recycler.class.getName()).getDeclaredMethod("clear"); declaredMethod.setAccessible(true); declaredMethod.invoke(declaredField.get(binding.recyclerView)); RecyclerView.RecycledViewPool recycledViewPool = recyclerView.getRecycledViewPool(); recycledViewPool.clear();&#125; catch (Exception e) &#123; e.printStackTrace();&#125; StatusBar在 SDK 21 以上，允许我们修改状态栏的颜色： 1234567if (Build.VERSION.SDK_INT &gt;= 21 &#123; TypedValue typedValue = new TypedValue(); Resources.Theme theme = getTheme(); theme.resolveAttribute(R.attr.color, typedValue, true); getWindow().setStatusBarColor( ContextCompat.getColor(mContext, typedValue.resourceId));&#125; 夜间模式的实现就到此，在重新设置颜色的部分比较繁琐，但这是我目前看到效果比较好的实现方式。效果如下： 项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[维基百科 MediaWiki API 解析]]></title>
      <url>%2F2017%2F12%2F13%2F201712132025%2F</url>
      <content type="text"><![CDATA[使用开放的 API 做一个自己的小项目，是一个很好的学习方法。但好像开放的 API 选择并不多。这里给大家多一个选择，简单介绍一下维基百科使用的 MediaWiki API。 简介先简单介绍几个容易混淆的概念。 WikiWiki 是一种在网络上开放且可供多人协同创作的超文本系统。Wiki 站点可以由多人维护，不同人可以对同一个主题进行拓展和探讨。 MediaWikiMediaWiki 是一个免费、开放的 Wiki 引擎，很多著名的 wiki 网站都采用这套系统。 Wikipedia我们常说的维基百科，一般是指 Wikipedia，它是基于 MediaWiki 的一个网络百科全书。 但要理解的是，除了 Wikipedia，还有很多别的 Wiki 站点。从这个角度考虑的话，维基（Wiki）也有可能是指别的网站，不过 Wikipedia 太出名了，以至于很多人直接将 Wikipedia 等同于 Wiki。 文档在了解到维基百科的 API 是开放的之后，我就找到了官方的 API 文档，但以我目前的水平，这个文档几乎完全看不懂。在网上找了很久，希望可以有一篇文章以中文看得懂的方式，告诉我这些 API 是怎么用的，但很可惜并没有。 没办法，自己对着官方文档琢磨了很久，勉强总结出一些比较常用的调用方法。希望本文可以让你对 MediaWiki 的内容获取有一个大概的了解，让你能用它做出自己的项目。 本文所有内容都来自以下官方文档，如果能看懂，就不用再往下看啦。 MediaWiki API Wikipedia API 为了方便理解，下面的说明都会有例子，用的是「灰机wiki」的「冰与火之歌中文维基」站点，域名是 asoiaf.huijiwiki.com，并通过 api.php 访问。当然，只要是基于 MediaWiki 的 Wiki 站点，下面说明都是适用的。 action接口中的 action 用来指定请求相应的动作，他的可取值非常非常多。我们这里只考虑内容的获取，不进行用户管理、内容编辑等操作，所以只要知道一个值就行了，所有接口都是 action = query。query 就是代表获取数据。 format这个用来指定数据返回的格式，我们统一用 JSON 格式，即 format = json。 但我在使用过程中发现，返回的 JSON 数据很多都是用「*」号或者是数字作为字段名的，解析起来很麻烦。这种情况下可以尝试增加 formatversion = 2，让返回的数据更正常一些，便于解析。 list在 action = query 的情况下，会增加一些可用的参数，其中 list 是比较常用的一个。list 的可选值也很多，下面是几个我认为比较常用的值。 allcategories在对一个站点还不是很了解的情况下，我们可以先看一下它有哪些分类。list = allcategories 代表列举出所有分类： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;list=allcategories&amp;aclimit=50 其中，aclimit 指定了返回的条目数量，默认值是 10，不能超过 500。 当数据存在下一页的时候，返回的数据里会有 continue 字段，比如： 1234continue: &#123; accontinue: "Castle_Black", continue: "-||"&#125; 要获取下一页，把 accontinue 这个参数带上就行： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;list=allcategories&amp;aclimit=50&amp;accontinue=Castle_Black categorymembers现在我们知道有哪些分类了，接下来想看一下某个分类下有哪些内容，就要用到 categorymembers，它用于列出指定分类中的所有页面。分类名传入 cmtitle，需要包括「Category:」这个前缀。 假如我想看一下「史塔克家族」有哪些页面： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;list=categorymembers&amp;cmtitle=Category:史塔克家族&amp;cmlimit=50 这里控制返回数量的是 cmlimit，获取下一页的是 cmcontinue。 random要是我想给用户一种新鲜感，每次在首页随机展示一些内容，list = random 是你需要的，它用于随机返回一些内容： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;list=random&amp;rnlimit=50&amp;rnnamespace=0 rnlimit 控制返回的数量，默认是 1。同理，获取下一页要用 rncontinue。后面也是类似的。 这里还有一个命名空间 NameSpace 的概念。当 rncontinue = 0 代表指定返回的是页面，rncontinue = 6 是文件，rncontinue = 14 是分类，别的我还没有用到过。 search搜索功能肯定是少不了的，我们用 list = search，将关键字传给 srsearch 进行搜索。 搜索含有「史塔克」的页面： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;list=search&amp;srsearch=史塔克&amp;srnamespace=0&amp;srlimit=10 目前我用到的 list 取值就这些。下面讲一下另一个重要的参数。 prop如果是要获取某个页面的相关数据，就涉及到 prop 这个参数。它用来指定要获取的数据类型，它的可选值也很多，下面也挑几个常用的说。 categories这个用来获取页面所属的所有分类，比如艾德·史塔克属于史塔克家族，也属于国王之手： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;prop=categories&amp;titles=艾德·史塔克&amp;cllimit=20 images除了文字描述，图片也是内容里的一个重要信息，prop = images 用来获取指定页面的所有文件。虽然是 image，但是它能获取到各种文件，包括视频： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;prop=images&amp;titles=艾德·史塔克&amp;imlimit=50 pageimagesprop = pageimages 也是用来获取页面图片的，按我的理解，它是用来获取页面封面的。比如我们获取「艾德·史塔克」的封面： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;prop=pageimages&amp;titles=艾德·史塔克&amp;pithumbsize=500 pithumbsize 用来指定图片的尺寸，默认只有 50 px。另外要注意，不是每个页面都是有封面的。 revisions接下来是最重要的获取页面内容了。revisions 文档解释是用来获取修订版本信息的，可以用来获取最新的页面数据。 我这样来获取「艾德·史塔克」的页面数据： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;prop=revisions&amp;titles=艾德·史塔克&amp;rvprop=content&amp;rvparse=true rvprop = content 表示需要返回页面的文本内容。rvparse = true 表示将文本内容解析为 html，否则是纯文本内容。 除了 content，rvprop 还有很多可选值，同时需要多种内容，可以用「|」分隔。比如同时返回修订时间戳、修订的用户及修订内容，可以这样表示：rvprop=timestamp|user|content。 其实很多参数的取值都是支持使用「|」的，将多条数据一起返回。比如我们将上面提到的 prop 取值一次全部获取到，可以这样调用： http://asoiaf.huijiwiki.com/api.php?action=query&amp;format=json&amp;formatversion=2&amp;prop=categories|images|pageimages|revisions&amp;titles=艾德·史塔克&amp;rvprop=timestamp|user|content&amp;rvparse=true 总结上面介绍的这些只能算是接触到 MediaWiki API 的一点皮毛而已，但我还是花了些时间才总结出来的。想要有很深入的了解，还是要去研究一下官方文档。 我用冰与火中文维基的接口写了一个 Android App，叫「冰与火维基」，但还有一些没优化好的地方，感兴趣的可以在这里下载到。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[打造自己的 APP「冰与火百科」（三）：Material Design 控件]]></title>
      <url>%2F2017%2F09%2F27%2F201710141046%2F</url>
      <content type="text"><![CDATA[自从 Google I/O 2014 发布 Material Design 到现在，这个设计语言已经相当完善了。Material Design 是我最喜欢的一种设计，在项目中，我会尽可能的使用 Material Design 的控件。 下面给大家简单介绍一下「冰与火百科」里面涉及到的 Material Design 控件。 侧滑菜单APP 里需要一个切换内容以及设置的地方，使用侧滑菜单是最好的选择。过去我们都是用 SlidingMenu 这样的第三方控件实现侧滑菜单，随着 Design 库的发布，我们有了官方的侧滑菜单。 在 Android Studio 里新建项目的时候，可以直接选择带有侧滑菜单的模板： 如果没有选模板，记得在 build.gradle 添加设计库的依赖： 1compile &quot;com.android.support:design:$&#123;SUPPORT_LIB_VERSION&#125;&quot; DrawerLayout我们看一下首页的布局： 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/drawer_layout" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:openDrawer="start"&gt; &lt;include layout="@layout/app_bar_main" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;android.support.design.widget.NavigationView android:id="@+id/nav_view" android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="start" android:fitsSystemWindows="true" app:headerLayout="@layout/nav_header_main" app:menu="@menu/activity_main_drawer" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; DrawerLayout 包含了主视图及侧滑菜单，负责控制侧滑的效果。而 NavigationView 就是我们的侧滑菜单。 如果使用了 ToolBar，并且要实现侧滑菜单的状态和 ToolBar 上的按钮联动，像这样： 在初始化的时候加入如下代码就可以实现了： 12345678ActionBarDrawerToggle toggle = new ActionBarDrawerToggle( this, drawerLayout, toolbar, R.string.navigation_drawer_open, R.string.navigation_drawer_close);drawerLayout.addDrawerListener(toggle);toggle.syncState(); NavigationView从 NavigationView 的布局属性可以看出，它由头部 headerLayout 及菜单列表 menu 两部分组成。 头部 headerLayout 就是一个普通布局，通常用渐变色或者图片来作背景，在上面显示程序名或用户信息。 下面的菜单列表，需要引入一个 menu 配置文件，这个文件我是这样写的： 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;group android:checkableBehavior="single"&gt; &lt;item android:id="@+id/nav_person" android:checked="true" android:icon="@drawable/menu_person" android:title="人物" /&gt; &lt;item android:id="@+id/nav_house" android:icon="@drawable/menu_house" android:title="家族" /&gt; &lt;item android:id="@+id/nav_history" android:icon="@drawable/menu_history" android:title="历史" /&gt; &lt;item android:id="@+id/nav_castles" android:icon="@drawable/menu_castle" android:title="城堡" /&gt; &lt;item android:id="@+id/nav_night" android:checkable="false" android:icon="@drawable/menu_bulb" android:title="夜间模式" app:actionLayout="@layout/menu_switch" /&gt; &lt;/group&gt;&lt;/menu&gt; 前四项是用于切换显示不同类型的单选按钮。 最后一项是夜间模式的切换按钮。它不可点击，并且通过 actionLayout 引入了另一个布局，布局里是一个开关控件 SwitchCompat。 Listener给 NavigationView 设置监听器，可以实现对侧边栏菜单的点击监听： 123456789101112131415navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.nav_person: //... break; case R.id.nav_night: boolean isChecked = switchCompat.isChecked(); switchCompat.setChecked(!isChecked); break; &#125; return true; &#125;&#125;); 顺便说一下这里 switchCompat 的获取： 1234Menu menu = navigationView.getMenu();MenuItem nightItem = menu.findItem(R.id.nav_night);View nightView = MenuItemCompat.getActionView(nightItem);SwitchCompat switchCompat = (SwitchCompat) nightView.findViewById(R.id.switch_compat); 侧滑菜单相关代码基本就这些了，看一下最终的实现效果： 标签选项卡过去要实现顶部标签栏，也是只能依赖第三方库，现在有了 TabLayout，可以很简单就实现这个效果。 布局如下： 123456&lt;android.support.design.widget.TabLayout android:id="@+id/tab_layout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabMode="scrollable" app:theme="@style/ThemeOverlay.AppCompat.Dark" /&gt; 设置 tabMode 为 scrollable，让标签栏宽度超过占用的宽度时可以滚动，不然会将所有标签压缩在占用的宽度里。 我们知道选项卡是要和 ViewPager 搭配使用的，在初始化时加一句让它们关联起来就行了： 1tabLayout.setupWithViewPager(viewPager) 这么简单又实现了一个功能： 下拉刷新相信很多人都接触过 PullToRefresh 这样的第三方下拉刷新控件，现在我们来看看 Material Design 的下拉刷新 SwipeRefreshLayout。 在布局里用 SwipeRefreshLayout 包裹要实现下拉刷新的区域，到顶部下拉便会出现加载框，并触发监听器的 onRefresh 方法。我们这样来监听下拉刷新： 123456swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() &#123; @Override public void onRefresh() &#123; load(); &#125;&#125;; 可以通过 setRefreshing 方法主动开始或停止刷新。 效果如下： 可折叠标题栏在 APP 里，经常会有一个标题栏，用于显示页面标题、放置搜索或设置按钮。它的作用不言而喻，但在寸土寸金的屏幕里它却一直占据着一块固定的区域。现在，我们能够实现在合适的时候将标题栏折叠起来。下面简单介绍一下涉及到的几个控件。 Toolbar经过 TitleBar、ActionBar 的发展，现在我们用 Toolbar 来实现标题栏： 1234&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize"/&gt; 在代码中初始化： 123456setSupportActionBar(toolbar);ActionBar actionBar = getSupportActionBar();if (actionBar != null) &#123; // 设置左边按钮可点击 actionBar.setDisplayHomeAsUpEnabled(true);&#125; AppBarLayoutAppBarLayout 继承自 LinerLayout，支持滑动。要让 Toolbar 响应折叠效果，需要把 AppBarLayout 作为 Toolbar 的父布局。 被 AppBarLayout 包裹的控件，可以设置一个 layout_scrollFlags 属性，即滑动折叠的类型。我给 Toolbar 设置了 1app:layout_scrollFlags=&quot;scroll|enterAlways&quot; 代表页面向上、向下滚动时，Toolbar 会跟着一起向上、向下滚动，直到完全隐藏或完全显示。 CoordinatorLayout单有 AppBarLayout 还不行，还要配合 CoordinatorLayout 使用才能实现折叠效果。CoordinatorLayout 作为一个上层布局，用来协调它的子布局间的交互。 综合上面几个控件，最终布局如下： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:id="@+id/appbar_layout" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_scrollFlags="scroll|enterAlways" /&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/tab_layout" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabMode="scrollable" app:theme="@style/ThemeOverlay.AppCompat.Dark" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:id="@+id/swipe_refresh_layout" android:layout_width="match_parent" android:layout_height="wrap_content" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/view_pager" android:layout_width="match_parent" android:layout_height="match_parent"/&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 要和 Toolbar 实现联动的控件，需要实现了 NestedScrollingChild 接口，并且配置「app:layout_behavior=”@string/appbar_scrolling_view_behavior”」。这里常用的控件有 SwipeRefreshLayout、NestedScrollView、RecyclerView。 基本都是布局代码，就可以实现这样的效果： CollapsingToolbarLayout除了简单的将 Toolbar 收起，还可以实现将图片收缩转换为 Toolbar 的酷炫效果。要实现这个效果需要使用 CollapsingToolbarLayout，用它包裹 ImageView 和 Toolbar： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="200dp"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_scrollFlags="scroll|exitUntilCollapsed"&gt; &lt;ImageView android:id="@+id/image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" app:layout_collapseMode="parallax" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" app:layout_collapseMode="pin" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:id="@+id/scroll" android:layout_width="match_parent" android:layout_height="match_parent" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;WebView android:id="@+id/web_view" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; CollapsingToolbarLayout 内的控件需要设置 layout_collapseMode 属性，可选值有： parallax 视差模式，随着页面滚动会有视差折叠效果 pin 固定模式，完全折叠后固定显示 效果如下： 卡片视图在 Material Design 里有一个概念是「卡片」，而 CardView 就是这个概念的直接体现。 CardView 其实就是一个带有 MD 风格的 FrameLayout，它可以有水波纹点击效果，可以设置圆角、设置 z 轴高度（阴影）。 用的时候记得添加依赖： 1compile &quot;com.android.support:cardview-v7:$&#123;SUPPORT_LIB_VERSION&#125;&quot; 用法跟 FrameLayout 是一样的，下面例子设置了水波纹点击效果以及圆角和 z 轴高度： 1234567891011&lt;android.support.v7.widget.CardView android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="10dp" android:foreground="?attr/selectableItemBackground" app:cardCornerRadius="5dp" app:cardElevation="5dp"&gt; &lt;!--...--&gt; &lt;/android.support.v7.widget.CardView&gt; 共享元素动画在 Material Design 里，希望页面的跳转能有一定的连贯性。 如果页面 A 和页面 B 拥有同一个元素，在 Android 5.0 之后，我们可以实现一种叫共享元素的过场动画，这个元素将会从页面 A 的位置，变换到页面 B 的位置。 在「冰与火百科」中，首页列表和详情页都显示了一张人物图片，就可以这样做。 在详情页的 ImageView 配置一个 transitionName，它是元素转换的一个标识： 123456&lt;ImageView android:id="@+id/image_view" android:layout_width="match_parent" android:layout_height="match_parent" android:scaleType="centerCrop" android:transitionName="tran_01"/&gt; 在首页跳转的代码，修改为： 123Pair[] pairs = new Pair[]&#123;new Pair(binding.ivImg, "tran_01")&#125;;ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(mainActivity, pairs);ActivityCompat.startActivity(context, intent, options.toBundle()); 这就是共享元素的效果： 小结借着写「冰与火百科」，把 Material Design 的部分常用控件归纳了一下。但这里只说了每个控件的基本用法，想有更深入的了解，还需要看查阅相关文章。 我不太懂设计，但有了这些控件，感觉「冰与火百科」还挺好看的~ 项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[腾讯云 wafer2 上手，轻松部署小程序后端！]]></title>
      <url>%2F2017%2F09%2F27%2F201709272129%2F</url>
      <content type="text"><![CDATA[前端程序员开发一个自己的小程序，比起学习小程序开发，更大的难点在于搭建小程序的后台。 本文从一个初学者的角度，简单介绍一下腾讯云推出的小程序解决方案 wafer2，让没有后台开发经验的程序员，也能搭建起自己的小程序后台。 简介wafer后台的搭建涉及到购买服务器、购买数据库，然后要在服务器上安装运行环境等。说实话，我连要在服务器上装什么都不知道。所以希望能有一个东西，帮我把这些都做好，要是再提供一些登录之类的常用接口就更好了。这就是 wafer 所做的。 其实在小程序后台配置域名的地方，就有跳转到腾讯云的链接: 进入后按照指引购买，就可以拥有一个配置好的后台。 wafer2wafer 相对于自己搭建后台已经方便很多了，但我用起来还是感觉有难度。我不熟悉 Linux，也搞不懂如何测试代码。直到发现腾讯云又推出了 wafer2。 如果你用上了新版小程序开发工具，会在工具的右上角发现一个「腾讯云」的按钮： 这个按钮就是用来连接 wafer2 的。 我们可以直接在小程序开发工具里编写后台代码，并上传代码，后台是区分开发环境和生产环境的。 下面我们看看怎么使用 wafer2。 搭建开发环境搭建 wafer2 很简单，大家按照官方文档来，应该没什么问题的，这里就不赘述了。 生产环境官方文档说的都是开发环境，要是你想部署到生产环境，有些配置需要改一下。 域名开发环境的域名是腾讯云分配的 xxx.qcloud.la，而生产环境需要使用自己在腾讯云里的域名。 通过腾讯云管理中心注册的域名，会自动部署 HTTPS 证书。但是要备案的话，需要登记服务器 ip，而 wafer2 的服务器 ip 是没有提供给我们的。目前备案只能再买一个服务器…… 绑定域名后，可以在开发工具「详情」-「腾讯云状态」确认生产环境域名： 切换到生产环境后，别忘了把客户端的接口域名也改一下。 数据库在腾讯云管理中心里，修改生产环境 MySql 的登录密码。然后登录 phpMyAdmin，在首页可以看到 MySql 的服务器 ip 地址，记下来。 回到开发工具，找到 server/config.js，修改里面 MySql 配置的 ip 地址及登录密码： 12345678mysql: &#123; host: &apos;修改为生产环境 ip&apos;, port: 3306, user: &apos;root&apos;, db: &apos;cAuth&apos;, pass: &apos;修改为生产环境密码&apos;, char: &apos;utf8mb4&apos;&#125;, 在开发工具上传正式代码，再到管理中心的生产环境，点击「代码部署」。这样就完成生产环境的配置及部署了。 比外需要注意，开发环境的 MySql 是 5.7 的，而生产环境是 5.6 的。注意不要在开发的时候使用 JSON 等 MySql 5.7 才有的功能。 登录先说一下小程序基本都会用到的登录。 使用wafer2 的客户端及服务端 sdk，已经集成了登录逻辑，在客户端引用 sdk 后，只要调用它的 login 方法就可以实现登录了： 12345678qcloud.login(&#123; success: res =&gt; &#123; console.log(&apos;登录成功&apos;, res) &#125;, fail: err =&gt; &#123; console.log(&apos;登录失败&apos;, err) &#125;&#125;) 登录成功会将用户数据保存在数据库 cAuth 的 cSessionInfo 表里，并将用户数据返回。 看起来很美好，但是这里面是存在一些问题的。 问题用户登录过之后会将用户信息缓存在本地，当有缓存的时候会将用户信息直接返回。但是 sdk 中，缓存的存取都是有问题的，有缓存的情况下，会返回 undifined。 这是个很低级的错误，问题已经给官方反馈了。截止到写这篇文章，取数据的地方改了，但存的地方还没改…… 所以现在要正常使用，需要到 wafer2-client-sdk/lib/login.js，找到保存用户数据的地方： 1Session.set(res.skey); 修改为： 1Session.set(res); 另外，还想吐槽一下，sdk 里 wx.login 和 wx.getUserInfo 是搭配使用的。 也就是说，必须要获取到用户信息，才能实现登录。而我们知道，小程序在获取用户信息时会弹窗，并且用户是可以拒绝的。拒绝后一段时间内，调用 wx.getUserInfo 都不会再弹窗。可以说 wafer2 没有考虑用户拒绝授权的情况。而这恰好是微信不提倡的做法，甚至可能导致无法通过审核。 这个问题我也向官方反馈了。 第一个接口学习要有目的性才能保持兴趣，配置完了我们来写一个自己的接口。 wafer2 基于 Node.js 平台，使用了 Koa2 框架。 在 server/controllers 下新建文件 hello.js，输入如下代码： 123module.exports = async ctx =&gt; &#123; ctx.state.data = &quot;Hello World !&quot;&#125; 代码很简单，就是暴露一个返回结果是「Hello World !」的方法，「Hello World !」会被放在请求结果的 data 里。 然后我们打开 server/routes/index.js 添加一句代码： 12// 测试接口router.get(&apos;/hello&apos;, controllers.hello) 代码就只有这么多。保存之后点击「腾讯云」-「上传测试代码」，如果是第一次上传要勾上「部署后自动安装依赖」。等待上传成功，就可以测试我们的接口了。 调用 xxx.qcloud.la/weapp/hello，看是否返回以下结果： 1234&#123; code: 0, data: "Hello World !"&#125; 恭喜！你自己开发的第一个接口已经调通了！ 数据库操作wafer2 使用了 knex 作为数据库的查询构造器，并且已经配置好了。对于有 sql 经验的程序员，可以很快的上手。 我们可以在 phpMyAdmin 里，在 cAppinfo 这个数据库里创建需要的表。 假如已经有一个「Book」的表，下面代码，简单展示了在 wafer2 里，如何对数据库进行增查改删： 123456789101112131415161718192021const &#123; mysql &#125; = require(&apos;../qcloud&apos;)const uuid = require(&apos;node-uuid&apos;)module.exports = async ctx =&gt; &#123; var id = uuid.v1() // 增 var book = &#123; id: id, name: &quot;冰与火之歌&quot;, price: 88 &#125; await mysql(&quot;Book&quot;).insert(book) // 查 var res = await mysql(&quot;Book&quot;).where(&#123; id &#125;).first() // 改 await mysql(&quot;Book&quot;).update(&#123; price: 66 &#125;).where(&#123; id &#125;) // 删 await mysql(&quot;Book&quot;).del().where(&#123; id &#125;) ctx.state.data = &quot;OK&quot;&#125; 数据库操作默认都是异步执行的，如果要等待操作完成，需要在操作语句前加上 await。 更高级的 sql 用法，可以查看 knex.js 官网。 总结我已经将自己的小程序「碰词er」后台迁移到 wafer2 了。开发的时候各种坑，给腾讯云提了一些很明显的 bug。说不定「碰词er」是第一个使用 wafer2 的小程序。 wafer2 用起来方便。我们不用懂太多后台配置的东西，前后端代码都在小程序开发工具编写，直接在开发工具上传后端代码，区分了开发、生产环境，而且目前还是免费的，虽说不知道会不会一直有免费版。 但目前缺点同样明显，比如备案不方便，登录接口不合理，sdk 有 bug 等。我还碰到服务器宕机，需要重启的情况。希望腾讯云接下来能解决这些问题。 总的来说，wafer2 使用门槛低，但现在还不够稳定。个人项目玩玩还是可以的，商业项目要用的话，建议再观察一段时间吧。 刚开始，在没有推广的情况下，在我身边的人都不愿意玩的情况下，每天会有一两百个新用户。在上次知晓程序推荐过后，现在居然每天有一两千个新用户！流量费都快给不起了，非常感谢大家的捧场。 最后，感谢我家宝宝做了这么好看的设计图。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我做了一个成语接龙的小程序]]></title>
      <url>%2F2017%2F08%2F27%2F201708271324%2F</url>
      <content type="text"><![CDATA[我是一名安卓程序员，以前没有接触过前端开发，直到有幸接手了公司的小程序项目。小程序学起来还是很快的，对于有编程经验的人，看着示例代码，对照着官方文档，几天就能上手了。 自从接触了小程序，一直想做一个自己的东西，要是每天有点人用就更好了。 有一天和我家宝宝玩成语接龙，突然想到，我可以做一个成语接龙的小程序啊！ 产品琢磨了两天，大概想做成这样： 接龙可以有「所有人可参与」、「指定群成员参与」等类型 不校验是否是成语，否则就无法使用「印贼做父」了 成语的读音，还是要校验一下的 难免会有人乱填，所以每条成语可以赞，也可以踩 在有一定数据量后可以增加排行榜 设计想法有了，还有两件比较棘手的事： 起个牛逼的名字 求我家宝宝给我画设计图 我想过很多名字，「成语接龙吧」、「接下去」、「接吧」、「接一个」… 宝宝：low 爆了，叫「碰词」，碰也有接的意思，成语也是个词嘛 这么 6 的名字居然有人先想到了，于是最终决定用「碰词er」 随便放两张设计图，美如画啥的就不说了： 下面说一下在开发方面，几个我认为值得一提的地方。 获取用户信息现在大部分的小程序都是一打开，就弹出用户信息授权框，有的甚至强制需要授权才可使用。我之前做的一个也是需要拿到 unionId 去登录才能使用的，为此我还写过一篇文章说明如何实现。 但显然，微信认为这是一个很不好的体验。在用户没有接触你的小程序之前，凭什么要信任你，把自己的用户信息暴露给你。 为了规范用户信息的获取，官方出了这篇文章：获取用户信息方案介绍（FAQ 里面有两个问题还是我提的） 刚好拿这个小程序来实践一下。 首先，明确什么情况下需要用到用户信息。这里需要用户信息显示在成语旁，所以在创建接龙或者发送成语之前，需要先获取到用户信息。如果你只是进来看看，是不需要你任何授权的，只有点击了创建接龙的按钮，或者发送成语的按钮，才会弹出授权提示框。 我是这样做的。没有用户信息时，设置 button 的 open-type 为 getUserInfo，点击会触发用户信息的获取。要是已经有用户信息了，则是一个普通的跳转按钮： 12345678&lt;view class="create-button"&gt; &lt;button wx:if="&#123;&#123;hasUserInfo&#125;&#125;" class="button" bindtap="navigateToCreate"&gt; &lt;image class="img" src="/images/icon_add.png" mode="aspectFit"/&gt; &lt;/button&gt; &lt;button wx:else class="button" open-type="getUserInfo" bindgetuserinfo="getUserInfo"&gt; &lt;image class="img" src="/images/icon_add.png" mode="aspectFit"/&gt; &lt;/button&gt;&lt;/view&gt; 当用户确定授权了，可以在 bindgetuserinfo 绑定的方法里，用 e.detail.userInfo 拿到用户信息。 但还有个问题，open-type=”getUserInfo” 要到基础库 1.3.0 才能用，最好还是做一下低版本兼容处理。 群能力目前，小程序已经支持获取到微信群的群 id 和显示群名。 当用户创建的接龙类型是指定群成员参与时，指定的群就是第一个转发到的群。而成员也只有通过这个群的分享进入小程序，才可参与接龙。下面说说这两种情况是如何获取到群 id 的。 在可分享的页面，调用 wx.showShareMenu() 显示转发按钮。添加 onShareAppMessage 方法，并在里面设置分享信息： 12345678910onShareAppMessage: function () &#123; var that = this return &#123; title: &quot;一起来玩成语接龙！&quot;, path: &apos;pages/xxx/xxx?id=&apos; + this.data.id, success(res) &#123; that.getShareInfo(res.shareTickets[0]) &#125; &#125;&#125; 在 getShareInfo 方法里，需要获取到分享信息，现在能获取到的只有群 id： 123456wx.getShareInfo(&#123; shareTicket: shareTicket, success(res) &#123; // 解密获取到 openGId &#125;&#125;) 这里和 getUserInfo 一样，拿到的数据是加密的，需要将 res.encryptedData 和 res.iv 传给后台解密。加密方式和 userInfo 是一样的，所以可以用同一个接口解密。解密后的 openGId 就是我们要的群 id。 至于从微信群进入的情况，我们需要对 app.js 的 onLaunch 方法动手。在 onLaunch 方法里可以获取到一个场景值，它区分了各种进入小程序的场景，各种场景值说明可以在这里查到。其中可以看到： 当场景值为 1044 时，我们就可能获取到携带的 shareTicket： 12345onLaunch: function (ops) &#123; if (ops != null &amp;&amp; ops.scene == 1044) &#123; this.globalData.shareTicket = ops.shareTicket &#125;&#125; 之后再对这个 shareTicket 进行解密，获取 openGId，判断用户是否可参与。 聊天列表从设计图可以看到，成语列表是置底的，类似微信聊天的效果。但列表都是默认置顶的，如何让它置底呢？ 其实很简单，这里利用了 scroll-view 组件的 scroll-into-view 属性： 注意这里有个细节，id 不能以数字开头，但我的 id 就是数字开头的怎么办？前面随便加个字母就好了： 123&lt;scroll-view class="scroll" scroll-y="true" scroll-into-view="x&#123;&#123;toView&#125;&#125;"&gt; &lt;!-- ...... --&gt;&lt;/scroll-view&gt; item 的 id 前面也记得加个 x。 然后在获得页面数据 setData 之后，将列表定位到底部： 12345setTimeout(function () &#123; that.setData(&#123; toView: list[list.length - 1].id &#125;)&#125;, 300) 这里的延时是不可少的，因为页面渲染需要点时间，不同性能的手机需要的时间还不一样。看过几台手机，300 毫秒应该是比较合适的。 如果要实现滑动到顶部加载更多的话，可以用上 bindscrolltoupper 这个属性： 获取更多后，将 toView 设置为新获取到的列表最后一项的 id。 浮动按钮首页右下角的按钮美如画，但是它会造成一定的遮挡。 安卓里有一个叫 FloatActionButton 的控件，当列表滚动时，可以向下移动隐藏，我尝试在小程序里实现类似的效果。 我觉得遮挡其实只对列表最底部有影响，所以当列表滚到底部时隐藏就好了，发生滚动再显示。 在不使用 scroll-view 的情况下，页面触底会触发 onReachBottom 方法，滚动会触发 onPageScroll 方法，所以这个功能可以这样实现： js 12345678910111213onReachBottom: function (event) &#123; // 隐藏按钮，避免遮挡 this.setData(&#123; showBtn: false &#125;)&#125;,onPageScroll: function (event) &#123; // 显示创建按钮 this.setData(&#123; showCreateBtn: true &#125;)&#125; wxml 1&lt;view class="button &#123;&#123;showBtn?'show-button':'hide-button'&#125;&#125;"/&gt; wxss 123456789.show-button &#123; transform: translateY(0); transition: 0.3s;&#125;.hide-button &#123; transform: translateY(180rpx); transition: 0.3s;&#125; 是不是很简单，效果还不错： 但是这里面有两个坑： 在开发工具上没什么问题，但在真机上，列表到达底部触发 onReachBottom 之后，居然还会触发 onPageScroll。我的做法是在 onReachBottom 之后的三百毫秒内不显示按钮。 在列表高度不满屏幕高度时，向上滑动列表，也会触发 onReachBottom，但是不会触发 onPageScroll，导致隐藏后就不会再显示了。解决方法是，可以先判断列表是否可滚动，不可滚动的情况下不隐藏按钮。 总结刚开始，在没有推广的情况下，在我身边的人都不愿意玩的情况下，每天会有一两百个新用户。在上次知晓程序推荐过后，现在居然每天有一两千个新用户！流量费都快给不起了，非常感谢大家的捧场。 最后，感谢我家宝宝做了这么好看的设计图。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小程序可以显示群名称啦！]]></title>
      <url>%2F2017%2F07%2F29%2F201707290929%2F</url>
      <content type="text"><![CDATA[开今年 5 月份的时候，微信宣布：「为了更好的针对群场景提供个性化服务，当用户在群聊中点击小程序分享卡片时，小程序支持开发者获取群 ID 和群名称」。但随后没多久，发现小程序只返回了群 ID，并没有给我们群名。现在，终于有方法可以显示群名称啦！ 前言直到现在，网上还可以看到很多「开发者可以获取群名称」这样的新闻。在微信刚宣布的时候确实同时返回了群 ID 和 群名称，但随后就只能获取到群 ID 了。估计会有很多开发者跟我一样被文章误导了，还以为是自己代码有问题。 至于微信为什么这么做，官方也作出了解释： 这就导致了，目前很多和群关联的小程序，一进去就要设置群备注的尴尬现象。 为了保护用户的隐私，同时满足开发的需求，微信需要找到一种获取不到，但又允许展示的方法。 现在微信找到方法了。 下面我们看看如何在小程序里面显示群名称。 获取群 ID显示群名的前提是，已经获取到了该群的群 ID。要是你之前已经对获取群 ID 有所了解，可以直接跳到后面看。 我们通过将小程序转发到群里，获取到对应群的群 ID。 首先，需要设置显示当前页面的转发按钮，转发后返回 ShareTicket，有了它才能去获取群 ID： 123wx.showShareMenu(&#123; withShareTicket: true &#125;) 在代码里面添加 onShareAppMessage 方法，它是用来控制转发功能的。转发成功后，拿到 ShareTicket，再调用 wx.getShareInfo 获取转发目标的信息。代码如下： 1234567891011121314151617onShareAppMessage: function () &#123; var that = this return &#123; title: "转发标题", path: '页面路径', success(res) &#123; wx.getShareInfo(&#123; shareTicket: res.shareTickets[0], success(res) &#123; console.log(res.encryptedData) console.log(res.iv) // 后台解密，获取 openGId &#125; &#125;) &#125; &#125;&#125; 和 wx.getUserInfo 一样，微信给了我们一段加密的数据，加密的方式也是一样的，后台可以用同一段代码进行解密。解密后的格式如下： 1234567&#123; "openGId": "xxxxxxxx", "watermark": &#123; "appid": "xxxxxxxx", "timestamp": 1499841984 &#125;&#125; openGId 就是我们要的群 ID 了，把它保存下来。 显示群名下面我们来到布局文件。 小程序刚更新，多了一个新组件 open-data： 用起来很简单，在要显示群名的地方，使用以下代码： 1&lt;open-data type="groupName" open-gid="&#123;&#123;openGId&#125;&#125;" /&gt; 将 openGId 传入，就会显示出群名称了，妥妥的。 但这个东西是基础库 1.4.0 才有的东西，最好还是用 wx.getSystemInfo 获取到当前客户端的基础库版本，做一下低版本兼容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[打造自己的 APP「冰与火百科」（二）：接口、索引页]]></title>
      <url>%2F2017%2F07%2F29%2F201707290917%2F</url>
      <content type="text"><![CDATA[开始「冰与火百科」开发之旅！ 网络数据先说一下我的接口是怎么来的。 存放数据首先确定自己需要一些什么数据，在满足自己要求的情况下越简单越好。对每个详情页面，我需要一张图片和一个 html 显示描述就够了。以奶德为例，在服务器的对应目录下，就会有 Eddard_Stark.png 和 Eddard_Stark.html 这两个文件。 这一步其实是整个项目最麻烦的地方。图片还好，但收集整理描述的内容真的要非常有耐心，至今才造了十几条数据。 创建数据集合我需要两个实体类。一个是分类，也就是到时 TabLayout 中的 Tab，另一个就是内容。对应的要生成两个 json 文件。 创建一个 java 项目，添加 Gson 依赖，建立两个要转换 json 的集合： 12private static List&lt;TabDTO&gt; tabList = new ArrayList&lt;&gt;();private static List&lt;ContentDTO&gt; contentList = new ArrayList&lt;&gt;(); 再次以奶德为例，往里面添加数据： 1tabList.add(new TabDTO(10100,&quot;person&quot;,&quot;Stark&quot;,&quot;史塔克&quot;)); 123456789String starkUrl = &quot;person/Stark/&quot;;contentList.add(new ContentDTO( &quot;Eddard_Stark&quot;, &quot;person&quot;, &quot;Stark&quot;, starkUrl + &quot;Eddard_Stark.png&quot;, &quot;艾德·史塔克&quot;, &quot;临冬城公爵、北境守护&quot;, starkUrl + &quot;Eddard_Stark.html&quot;)); 生成 json 文件完了输出为 json 文件就好了，以 content 为例： 12345678910111213Gson gson = new Gson();String jsonString = gson.toJson(contentList);File contentJsonFile = new File("../IceAndFireServer/content.json");try &#123; OutputStreamWriter osw = new OutputStreamWriter( new FileOutputStream(contentJsonFile), "UTF-8"); BufferedWriter bw = new BufferedWriter(osw); bw.write(jsonString, 0, jsonString.length()); bw.flush(); bw.close();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 然后将数据上传到网络就好了，json 文件所在的网络地址就是你的接口了。刚开始我上传到了 GitHub，但发现经常会发生灵异事件，导致数据无法访问或者速度超慢，后来又上传到了九牛云。 这部分内容大家看一下就好了，毕竟不是常规的做法。有兴趣的可以到这里，数据和代码都在里面了。 APP主题色下面终于来到我们的 Android 项目了。 创建 Android 项目后，第一反应是主题色得改一改。 在官方 Material Design 的色板里面，我选用了这一套： 对应的，color 文件的主题色值修改如下： 123&lt;color name="colorPrimary"&gt;#607d8b&lt;/color&gt;&lt;color name="colorPrimaryDark"&gt;#546e7a&lt;/color&gt;&lt;color name="colorAccent"&gt;#40c4ff&lt;/color&gt; 索引页我也学着别的 APP，做一个索引页 IndexActivity。就简单展示一句「挖了蘑菇立死」，噢不对，展示一句「Valar Morghulis」就好了，像这样： 加入一点简单的动画，然后还能做一些耗时的启动操作。 DataBinding我会比较在意代码的简洁性，在实现同样功能的情况下代码越少越好，而且排版一定要看上去舒服，缩进要少，甚至不允许代码里面有警告。 DataBinding 是一个可以增加代码简洁性的东西。这里以索引页为例，简单介绍一下它最简单的一个应用，代替 findViewByid。 配置在对应 Module 的 build.grade 里配置： 123456android &#123; .... dataBinding &#123; enabled = true &#125;&#125; 布局在需要绑定的布局文件里，最外层增加一个 layout 标签，比如这里的 activity_index.xml ： 123456789101112&lt;layout xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;TextView android:id="@+id/tv_index" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:text="@string/valar_morghulis" android:textColor="@color/color3A3A3A" android:textSize="36sp" /&gt;&lt;/layout&gt; 使用创建一个成员变量： 1private ActivityIndexBinding binding; 注意，这里的变量类型是和布局文件相关的，比如 ActivityIndexBinding 对应 activity_index。 然后将原来 setContentView 的地方修改为： 1binding = DataBindingUtil.setContentView(this, R.layout.activity_index); 当我要使用布局里的 TextView 的时候，直接用 binding.tvIndex 就可以了。tvIndex 这个名字是和布局里的 id：tv_title 相对应的。 DataBinding 的一些更高级的用法这里就不赘述了，网上的教程很多，大家可以多搜索了解一下。 动画为了让索引页的字更生动，我打算加一个渐变放大的动画效果。 xml我这里用的是 View Animation（视图动画），动画过程是通过 xml 文件定义的。在 res/anim 文件夹下新建一个 xml 文件，代码如下： 123456789101112131415161718192021&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@android:anim/decelerate_interpolator" android:shareInterpolator="true" &gt; &lt;scale android:duration="1300" android:fillAfter="true" android:fromXScale="0.95" android:fromYScale="0.95" android:pivotX="50%" android:pivotY="50%" android:toXScale="1" android:toYScale="1" /&gt; &lt;alpha android:duration="1300" android:fillAfter="true" android:fromAlpha="0" android:toAlpha="1" /&gt;&lt;/set&gt; 这个的意思很好理解，就是用 1.3 秒的时间，控件大小从 95% 渐变到 100%，透明度从 0 渐变到10%。 使用执行动画的代码也很简单，大家直接看吧： 123456789101112131415161718192021222324Animation animation = AnimationUtils .loadAnimation(this, R.anim.anim_valar_morghulis);animation.setAnimationListener(new AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; SystemClock.sleep(500); animationComplete = true; goMainPage(); &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125;&#125;);SystemClock.sleep(200);binding.tvIndex.startAnimation(animation); 为了让用户能看清动画，我在里面加入了一些停顿。经过我自己的多次试验，最终定下的这个停顿时常，我认为长度是在能看清动画的情况下，又不会长到让人感到厌烦的，效果如下： 耗时操作前面说到，在索引页可以做一些耗时的操作。动画的执行总共有两秒的时间，用户的时间是宝贵的，要是在这两秒里面什么都不做就太浪费了。 最耗时的操作，应该是调接口了。 其实刚开始我是进入到首页才调接口的，进入不同的页面获取不同的数据。但这样会有一个问题，由于我没有后台，只有两个假接口，所以搜索功能就无法实现了。 所以现在改为，在索引页获取到所有数据并保存起来，在不同分类页面下通过筛选展示数据，这样搜索也可以实现了。 下面就简单讲一下目前比较流行的两个框架 Retrofit 2 和 Realm，来完成数据的获取和保存。 Retrofit 2Retrofit 的厉害之处我就不多说了，网上的教程很多的，我只讲最最简单的用法。 配置在 Module 的 build.grade 里添加依赖： 123compile &quot;com.squareup.retrofit2:retrofit:$&#123;RETROFIT_VERSION&#125;&quot;compile &quot;com.squareup.retrofit2:converter-scalars:$&#123;RETROFIT_VERSION&#125;&quot;compile &quot;com.squareup.retrofit2:converter-gson:$&#123;RETROFIT_VERSION&#125;&quot; 目前最新版是 2.3.0，大家可以自行替换。 这里面 converter-scalars 是添加 String 类型的返回，converter-gson 是添加 Gson 的支持（返回实体类）。 接口定义新建一个接口文件（interface），用来统一管理所有要调用的接口（url），我暂时只有两个接口，再留一个通用的 Get 请求备用： 123456789101112public interface RequestServes &#123; @GET("&#123;url&#125;") Call&lt;String&gt; get(@Path("url") String url); @GET("tab.json") Call&lt;List&lt;TabDTO&gt;&gt; getTab(); @GET("content.json") Call&lt;List&lt;ContentDTO&gt;&gt; getContent();&#125; 注解 @GET 后面的内容就是要请求的接口，这里不用写基础域名（BaseUrl）。 初始化需要通过 Retrofit.Builder 初始化 Retrofit，调用 baseUrl 设置基础域名： 12345678Retrofit retrofit = new Retrofit.Builder() .baseUrl(ServerAPI.BASE_URL) //增加返回值为String的支持 .addConverterFactory(ScalarsConverterFactory.create()) //增加返回值为实体类的支持 .addConverterFactory(GsonConverterFactory.create()) .build();requestServes = retrofit.create(RequestServes.class); 需要注意的是，BaseUrl 必须以斜杠「/」结尾，否则会报错。 考虑到可能多个页面都需要调用接口，可以把这段代码放在 BaseActivity 里。 使用用起来超简单： 123456789101112131415Call&lt;List&lt;TabDTO&gt;&gt; call = requestServes.getTab();call.enqueue(new Callback&lt;List&lt;TabDTO&gt;&gt;() &#123; @Override public void onResponse(@NonNull Call&lt;List&lt;TabDTO&gt;&gt; call, @NonNull retrofit2.Response&lt;List&lt;TabDTO&gt;&gt; response) &#123; List&lt;TabDTO&gt; tabList = response.body(); //... goMainPage(); &#125; @Override public void onFailure(@NonNull Call&lt;List&lt;TabDTO&gt;&gt; call, @NonNull Throwable t) &#123; netError(); &#125;&#125;); 请求失败的时候，我会弹吐司提醒，并且让页面可点击重试。 RealmRealm 是 SQLite 的替代者，它更快速、更易用。下面看看 Realm 的简单使用。 配置修改 Project 下的 build.gradle : 1234567891011buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.3.3&apos; classpath &quot;io.realm:realm-gradle-plugin:3.5.0&quot; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125; 目前最新版是 3.5.0。然后再到 Module 的 build.gradle，添加： 1apply plugin: &apos;realm-android&apos; 配置完毕 初始化在使用 Realm 之前，必须先调用： 1Realm.init(this); 获取 Realm 实例有以下两种方法： 1Realm mRealm = Realm.getDefaultInstance(); 这里有个小细节。如果实体类的字段发生了改变，这里是会报错的。我的做法比较粗暴，清空数据库后再重新获取： 123456try &#123; mRealm = Realm.getDefaultInstance();&#125; catch (RuntimeException e) &#123; Realm.deleteRealm(Realm.getDefaultConfiguration()); mRealm = Realm.getDefaultInstance();&#125; 保存让需要保存下来的实体类继承 RealmObject，然后就可以使用以下代码保存了： 123mRealm.beginTransaction();mRealm.copyToRealm(list);mRealm.commitTransaction(); 查询查询也很简单，就一句代码的事： 1List&lt;Data&gt; list = mRealm.where(Data.class).findAll(); 复杂查询这里就不多说了。 需要注意的是，如果要对查询的结果进行修改或删除等操作，则必须要在 transaction 里完成，修改的结果会同步到数据库。比如，我想对上面查询到的第一个元素进行修改： 12345Data data = list.get(0)mRealm.beginTransaction()mRealm.copyFromRealm(data)data.num = 666mRealm.commitTransaction() 小结就先到这吧，一个索引页都能扯这么多。 其实我没什么想总结的，我只想提醒一下：GOT Session 7 ！！！ 项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[打造自己的 APP「冰与火百科」（一）：分析定位]]></title>
      <url>%2F2017%2F07%2F08%2F201707080908%2F</url>
      <content type="text"><![CDATA[回想自己最开始学习 Android 的动力，其实很简单，就是想在手机上看到自己设计的 APP。但是在工作后，一直做的都是「别人」的 APP，偶尔还要做一些自己不太认可的设计和交互，从中获取到的成就感还不及第一次在手机上看到「Hello World」。 所以我要打造一个属于自己的 APP，甚至接口都是自己的。遵循 Material Design，用上各种最流行的库，不适配低版本，反正自己怎么开心怎么做！ 这一篇基本都是在扯淡，如果是只对代码有兴趣的读者，可以翻一下我后面的文章写了没。 定位不知道大家有没有听说过，网上有一些自动生成 APP 的服务。在我还对编程一窍不通的时候，我做过一个这样的东西： 现在还忘不了当我拿这个去唬人时，别人「这是你做的？真的假的？」那种眼神。 我是乔治·R·R·马丁的小说「冰与火之歌」（后面可能会简称「冰火」）的粉丝，曾经连续读了前五卷，厚厚的十五本书啊！再加上一本「冰火」的百科，「冰与火的世界」： 其实我最早接触的是它的电视剧「权力的游戏」，但在没有任何知识背景的情况下，看的我一脸蒙蔽。很多东西是看了小说之后才焕然大悟，并且惊叹于这部作品尽如此宏大。在美剧的故事开始之前，漫长的历史里面也发生了许多故事。 于是就产生了做一个「冰火」百科的 APP 的想法，让没看过小说的人对这部作品有更多的了解， 科普小说美剧故事开始之前的故事，并且绝不会涉及剧透！ APP 名就叫「冰与火百科」好了。本来想叫「冰与火的世界」，但觉得还是要跟原著有所区分。另外，五个字可以让它在手机上完整显示，试了几台手机，超过五个字在手机桌面显示会有省略号。 图标我一直在想，有什么图案是可以代表「冰火」这部作品的，是作品名的艺术字，还是某个家族的家徽？No，No，No！ 在冰火里面，有个地方的人一见面会说「Valar Morghulis」，意思是「挖了蘑菇立死」，噢不对，是「凡人皆有一死」。我觉得这句活一定程度上可以概括这部作品，他们用的硬币上也印有这句话： 酷！就拿它做图标好了！ 在最新的 Android 原生系统上面，APP icon 都统一成了圆形： 为了响应谷歌的号召，按照扁平化加简洁的概念，经过老婆的处理，有了这么几个版本： 最终决定用最简洁的那个。 功能这个 APP 不会做的太复杂，就是一些基本的功能，和以前那个自动生成的差不多。 进入 APP 后，可以通过点击不同的分类，查看对应分类下的人物、城堡、历史事件等，点击进入详情（一个 WebView 的页面）。在详情页面可以通过点击文字跳转到另一个详情页面。差不多就这样了。 这好像也太简单了。。。 再加个搜索和夜间模式吧。 接口接口我是想自己做的，但就算我那么有耐心去收集后台数据，关键我不会后台啊！ 琢磨了几天后，我决定这样做。自己生成 json 数据，然后将 json 文件放到 GitHub 上面，直接去请求这个文件就好了！反正也不是要拿来上线的东西，用最简单的方式实现就好了。我怎么这么聪明啊。 所以难点就在于收集整理数据了，还要写一下 html 代码。 知识点要是没有意外，把现在想到的都实现了的话，在后面的文章，你可以接触到以下内容： 用静态网络数据打造自己的接口 部分 Material Design 控件的使用 一些流行框架的简单使用（DataBinding、Retrofit、Realm、Glide 等） Android 和 js 之前的简单交互 夜间模式的实现 搜索功能的实现 对初学者来说，算是一个可以学习一下的项目，妥妥的。 对了，还有一个星期「权力的游戏」第七季就来啦！想想还有些小激动。 项目地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[小程序没有授权时的处理方法]]></title>
      <url>%2F2017%2F06%2F23%2F201706231810%2F</url>
      <content type="text"><![CDATA[在做小程序开发的时候，我们经常会需要获取用户的一些权限。比如获取用户信息用于直接登录，获取地理位置用于定位等。但要是用户拒绝授权了，该怎么处理呢？ 问题分析在小程序里面，获取到用户权限是进行某些操作的必要前提。比如在进入小程序的时候，获取到用户信息，拿到 unionId 对应到自己平台的账号进行登录，免去用户自己输入账号密码，这就是一个不错的体验。 当我们调用 wx.getUserInfo 或者 wx.getLocation 这种需要用户授权的 API 时，小程序会弹框让用户选择授权： 当用户选择允许后，下次再进入小程序就不会再询问了，直接获得用户授权（除非将小程序删了再进入）。这里的问题在于，当用户点了拒绝之后，就拿不到相关授权了，并且在一段时间内，进入小程序都不会再出现这个弹框。 从用户体验及保护隐私的角度考虑，小程序最好是不用授权也可以使用（或者体验）。但有些类型的小程序确实是需要拿到用户信息才能使用的。这里提供一个简单的解决方案。 解决方案以获取用户信息直接登录为例。增加一个授权页面，作为进入小程序的第一个页面，在这里获取用户数据和登录。默认可以什么都不显示，也可以当做引导页来使用。 获取用户信息需要用到 wx.login 和 wx.getUserInfo 两个 API，关于这两个 API 的具体信息大家可以到官方文档去查看。 增加一个登陆方法，代码如下： 12345678910111213141516171819202122//登录login: function () &#123; var that = this if (typeof success == "function") &#123; this.data.getUserInfoSuccess = success &#125; wx.login(&#123; success: function (res) &#123; var code = res.code; wx.getUserInfo(&#123; success: function (res) &#123; //平台登录 &#125;, fail: function (res) &#123; that.setData(&#123; getUserInfoFail: true &#125;) &#125; &#125;) &#125; &#125;)&#125; 当上门代码走到了 fail 里面，就可以认为在获取授权的时候，用户点了拒绝。当 getUserInfoFail 为 true 的时候，可以展示一个获取授权的按钮，比如像这样： 接下来介绍另一个 API : wx.openSetting，使用 wx.openSetting 可以跳转到小程序的授权设置界面，在安卓里面它长这样： 在点击授权按钮后跳转到这里，让用户授权了才给进入首页，否则就停留在授权页面。 但还有个小问题，这个 API 是基础库 1.1.0 才有的，所以需要做兼容处理： 所以，最终跳转授权的代码如下： 1234567891011121314151617//跳转设置页面授权openSetting: function () &#123; var that = this if (wx.openSetting) &#123; wx.openSetting(&#123; success: function (res) &#123; //尝试再次登录 that.login() &#125; &#125;) &#125; else &#123; wx.showModal(&#123; title: '授权提示', content: '小程序需要您的微信授权才能使用哦~ 错过授权页面的处理方法：删除小程序-&gt;重新搜索进入-&gt;点击授权按钮' &#125;) &#125;&#125; 还好 1.1.0 已结算是比较早的版本了，现在都出到 1.3.0 了。 最终效果如下： 同样的处理方式也可以用在获取别的权限上，妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿 iOS 列表的编辑功能 - 排序篇]]></title>
      <url>%2F2017%2F05%2F25%2F201705252139%2F</url>
      <content type="text"><![CDATA[之前做过一个仿 iOS 列表的编辑删除功能，在快做完的时候发现在 iOS 里，编辑的时候还带有排序的功能，所以这次把排序功能加上，并做了一些优化。 现在的效果如下： 有兴趣的可以先看一下之前删除的那篇： 仿 iOS 列表的编辑功能 - 删除篇 按键布局首先，我们需要在布局中增加一个排序的按键，所以在 EditLayout 的成员变量增加： 12private View mSortView; //排序按键private int mSortWidth; //排序按键宽度 处于编辑状态时，才会显示编辑按键。 我把右边的删除按钮固定在右侧底部（感觉好看一点），为了让它处于其它控件的底部，item 布局文件的控件摆放顺序变成这样： 123456789101112131415&lt;EditLayout...&gt; &lt;!--右侧删除按键--&gt; &lt;view.../&gt; &lt;!--内容区域--&gt; &lt;view.../&gt; &lt;!--左侧预删除按键--&gt; &lt;view.../&gt; &lt;!--排序按键--&gt; &lt;view.../&gt;&lt;/EditLayout&gt; 相应的，获取及摆放控件改成这样： 1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mRightView = getChildAt(0); mContentView = getChildAt(1); mLeftView = getChildAt(2); mSortView = getChildAt(3);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = w; mHeight = h; mRightWidth = mRightView.getMeasuredWidth(); mLeftWidth = mLeftView.getMeasuredWidth(); mSortWidth = mSortView.getMeasuredWidth();&#125;@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); //判断是否为编辑模式,摆放每个子View的位置 mRightView.layout(mWidth - mRightWidth, 0, mWidth, mHeight); mSortView.layout(mWidth - mSortWidth, 0, mWidth, mHeight); if (isEdit) &#123; mContentView.layout(mLeftWidth, 0, mWidth, mHeight); mLeftView.layout(0, 0, mLeftWidth, mHeight); mSortView.setVisibility(VISIBLE); &#125; else &#123; mContentView.layout(0, 0, mWidth, mHeight); mLeftView.layout(-mLeftWidth, 0, 0, mHeight); mSortView.setVisibility(INVISIBLE); &#125;&#125; 三种状态在增加了排序功能后，三个状态也有了变化： 可以看到，进入编辑状态后，mContentView 的宽度发生了变化，那么我们在哪里改变它的宽度呢？ 缩短 mContentView 宽度在 ViewDragHelper.Callback 中，onViewPositionChanged 方法负责监听控件的位置变化。我们在这里判断，当左侧完全展开时，缩短 mContentView 的宽度： 1234567891011121314@Overridepublic void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; if (changedView == mContentView) &#123; mLeftView.offsetLeftAndRight(dx); mSortView.offsetLeftAndRight(dx); &#125; invalidate(); //左侧展开时，修改 mContentView 宽度 if (left == mLeftWidth) &#123; mContentView.layout(mLeftWidth, 0, mWidth, mHeight); mSortView.layout(mWidth - mSortWidth, 0, mWidth, mHeight); mSortView.setVisibility(VISIBLE); &#125;&#125; 复原 mContentView 宽度当结束编辑状态时，就将控件的宽度复原。我们需要先将宽度复原，再让它滑动到关闭的状态。这里会有两种情况，左边展开关闭和右边展开关闭。关闭时会调用 close() 方法，我们在这里做处理： 12345678910111213141516171819public void close() &#123; if (mOnStateChangeListener != null) &#123; mOnStateChangeListener.onClose(this); &#125; //将 mContentView 宽度复原 if (mContentView.getLeft() &gt; 0) &#123; //左边展开复原 mContentView.layout(mLeftWidth, 0, mWidth + mLeftWidth, mHeight); mLeftView.layout(0, 0, mLeftWidth, mHeight); &#125; else &#123; //右边展开复原 mContentView.layout(-mRightWidth, 0, mWidth - mRightWidth, mHeight); mLeftView.layout(-mLeftWidth - mRightWidth, 0, -mRightWidth, mHeight); &#125; mSortView.setVisibility(INVISIBLE); //滑动到关闭位置 mDragHelper.smoothSlideViewTo(mContentView, 0, 0); invalidate();&#125; UI 方面的改动就到这里。 排序ItemTouchHelper 可以让 RecyclerView 的 item 实现上下左右拖动，我们把排序的操作交给它处理。 ItemTouchHelper.Callback和 ViewDragHelper 类似，ItemTouchHelper 也有一个 Callback，我们自定义一个 EditTouchHelperCallback： 123456789101112131415161718192021222324252627public class EditTouchHelperCallback extends ItemTouchHelper.Callback &#123; @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; // 允许上下拖拽 int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; // 禁止左右拖拽 int swipeFlags = 0; return makeMovementFlags(dragFlags, swipeFlags); &#125; @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; return true; &#125; @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123; &#125; @Override public boolean isLongPressDragEnabled() &#123; //禁止长按触发拖拽 return false; &#125;&#125; 这几个方法都很好理解： getMovementFlags - 确定 item 是否可上下左右拖动，我们这里只允许上下拖动 onMove - 上下拖动 item 到另一个位置的回调 onSwiped - 左右拖动 item 的回调，这里不需要实现 isLongPressDragEnabled - 长按 item 是否会触发可拖动，默认返回 true，这里不需要 在 Activity 中，需要将 ItemTouchHelper 和 RecyclerView 绑定： 12mItemTouchHelper = new ItemTouchHelper(new EditTouchHelperCallback());mItemTouchHelper.attachToRecyclerView(mRecyclerView); 这样，我们的 item 就已经支持上下拖动了，但是要如何触发拖动以及交换控件位置呢？ OnItemSortListenerItemTouchHelper 有两种方式可以触发拖动，一个是上面说到的长按，还有就是调用它的 startDrag 方法。 至于交换位置，ItemTouchHelper 是不支持的，毕竟它负责的是单个 item 的操作。但我们 RecyclerView 的 Adapter 支持啊，它的 notifyItemMoved 方法就是用来交换 item 位置的。 所以我们创建一个监听器，用于监听开始拖拽及位置交换： 123456789/** * 排序监听器 */public interface OnItemSortListener &#123; void onStartDrags(RecyclerView.ViewHolder viewHolder); void onItemMove(int fromPosition, int toPosition);&#125; 这个监听器由 Activity 实现: 12345678910@Overridepublic void onStartDrags(RecyclerView.ViewHolder viewHolder) &#123; mItemTouchHelper.startDrag(viewHolder);&#125;@Overridepublic void onItemMove(int fromPosition, int toPosition) &#123; Collections.swap(mList, fromPosition, toPosition); mAdapter.notifyItemMoved(fromPosition, toPosition);&#125; 这两个方法在哪里调用？ 调用 Listener触发拖动的当然是排序按键。将 ItemTouchHelper 传给 Adapter，然后给排序按键设置触摸事件： 1234567891011viewHolder.vSort.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View view, MotionEvent motionEvent) &#123; if (isEdit &amp;&amp; mRightOpenItem != null) &#123; mRightOpenItem.openLeft(); &#125; else &#123; mOnItemSortListener.onStartDrags(viewHolder); &#125; return false; &#125;&#125;); 至于位置交换，不要忘了 ItemTouchHelper.Callback 里有个 onMove 方法。创建 EditTouchHelperCallback 时，将 OnItemSortListener 传入，然后在 onMove 里加一句代码： 12345@Overridepublic boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123; mOnItemSortListener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition()); return true;&#125; 这样就完成啦，妥妥。目前的效果还是比较满意的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[仿 iOS 列表的编辑功能 - 删除篇]]></title>
      <url>%2F2017%2F05%2F07%2F201705071147%2F</url>
      <content type="text"><![CDATA[在 iOS 的设置里面，有一种编辑的效果，进入编辑状态后，列表左边推出圆形的删除按钮，点击后再出现右边确认删除按钮，相当于给用户二次确认。看下在 Android 上如何实现。 iOS 的效果如下： 我实现的效果是这样的： 下面说说我是怎么做的吧。 EditLayout我们自定义了一个 EditLayout 继承 FrameLayout。可以看出，这个控件由左中右三部分组成，对应的，我在 EditLsyout 里创建了以下成员变量： 1234567private View mContentView; //内容部分private View mLeftView; //左边圆形删除按键private View mRightView; //右边删除按键private int mWidth; //内容部分宽度private int mHeight; //内容部分高度private int mLeftWidth; //左边部分宽度private int mRightWidth; //右边部分宽度 获取控件及宽高当 View 中所有的子控件 均被映射成 xml 后，会触发 onFinishInflate 方法，当 view 的大小发生变化时，会触发 onSizeChanged 方法，所以我们可以这样赋值: 12345678910111213141516@Overrideprotected void onFinishInflate() &#123; super.onFinishInflate(); mLeftView = getChildAt(0); mContentView = getChildAt(1); mRightView = getChildAt(2);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = w; mHeight = h; mRightWidth = mRightView.getMeasuredWidth(); mLeftWidth = mLeftView.getMeasuredWidth();&#125; 摆放控件位置获取到控件和宽高，我们就可以摆放它们的位置了。我们知道，View 是通过 onLayout 方法来摆放控件位置的。这里有两种摆放方式，编辑状态和非编辑状态，代码如下： 1234567891011121314@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; super.onLayout(changed, left, top, right, bottom); //判断是否为编辑模式,摆放每个子View的位置 if (EditAdapter.isEdit) &#123; mContentView.layout(mLeftWidth, 0, mLeftWidth + mWidth, mHeight); mRightView.layout(mWidth + mLeftWidth, 0, mRightWidth + mWidth + LeftWidth, mHeight); mLeftView.layout(0, 0, mLeftWidth, mHeight); &#125; else &#123; mContentView.layout(0, 0, mWidth, mHeight); mRightView.layout(mWidth, 0, mRightWidth + mWidth, mHeight); mLeftView.layout(-mLeftWidth, 0, 0, mHeight); &#125;&#125; 滑动效果滑动效果，我交给了 ViewDragHelper 处理。要使用 ViewDragHelper ，需要实现一个 ViewDragHelper.Callback，这是一个抽象类，我们这里只关注它的三个方法： 123456//返回值决定 child 是否可拖拽public boolean tryCaptureView(View child, int pointerId)//限定移动范围，返回值为对应控件的左边位置public int clampViewPositionHorizontal(View child, int left, int dx)//当 changedView 发生移动时的回调（可以用来更新其他子 View 的位置）public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) 我实现的 Callback 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ViewDragHelper.Callback mCallback = new ViewDragHelper.Callback() &#123; @Override public boolean tryCaptureView(View child, int pointerId) &#123; return false; &#125; @Override public int clampViewPositionHorizontal(View child, int left, int dx) &#123; if (child == mContentView) &#123; if (left &lt; -mRightWidth) &#123; left = -mRightWidth; &#125; else if (left &gt; mLeftWidth) &#123; left = mLeftWidth; &#125; &#125; else if (child == mRightView) &#123; if (left &lt; mWidth - mRightWidth) &#123; left = mWidth - mRightWidth; &#125; else if (left &gt; mWidth) &#123; left = mWidth; &#125; &#125; else if (child == mLeftView) &#123; if (left &lt; mWidth - mRightWidth) &#123; left = mWidth - mRightWidth; &#125; else if (left &gt; -mLeftWidth) &#123; left = 0 - mLeftWidth; &#125; &#125; return left; &#125; @Override public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) &#123; if (changedView == mContentView) &#123; mRightView.offsetLeftAndRight(dx); mLeftView.offsetLeftAndRight(dx); &#125; else if (changedView == mRightView) &#123; mContentView.offsetLeftAndRight(dx); mLeftView.offsetLeftAndRight(dx); &#125; else if (changedView == mLeftView) &#123; mContentView.offsetLeftAndRight(dx); mRightView.offsetLeftAndRight(dx); &#125; invalidate(); &#125;&#125;;mDragHelper = ViewDragHelper.create(this, mCallback); 对了，实现滑动还需要重写 computeScroll 方法： 1234567@Overridepublic void computeScroll() &#123; super.computeScroll(); if (mDragHelper.continueSettling(true)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125;&#125; 三种状态我们这个控件存在三种状态，分别是左边展开，右边展开，还有关闭。相应的，我们定义三个方法，用于滑动到不同的状态： 1234567891011121314151617181920212223242526272829303132/** * 展开左侧 */public void openLeft() &#123; if (mOnStateChangeListener != null) &#123; mOnStateChangeListener.onLeftOpen(this); &#125; mDragHelper.smoothSlideViewTo(mContentView, mLeftWidth, 0); invalidate();&#125;/** * 展开右侧 */public void openRight() &#123; if (mOnStateChangeListener != null) &#123; mOnStateChangeListener.onRightOpen(this); &#125; mDragHelper.smoothSlideViewTo(mContentView, -mRightWidth, 0); invalidate();&#125;/** * 关闭 */public void close() &#123; if (mOnStateChangeListener != null) &#123; mOnStateChangeListener.onClose(this); &#125; mDragHelper.smoothSlideViewTo(mContentView, 0, 0); invalidate();&#125; mOnStateChangeListener 是一个监听器，会在 EditLayout 状态改变的时候调用。我在回调方法里保存了当前向右展开的 EditLayout。 到这里，EditLayout 就完成了。 EditAdapter接下来看下适配器 EditAdapter。 item 布局item 的 xml 文件里面，最外层用我们的 EditLayout 包裹，然后里面的三个子布局，按顺序，对应我们左中右三个部分。 切换编辑模式这里需要定义一个 EditLayout 的集合 allItems，在 onBindViewHolder 的时候将布局添加进去。然后我们定义两个公开方法，用于切换所有 item 的状态，在切换编辑模式的时候调用： 1234567891011121314151617/** * 关闭所有 item */public void closeAll() &#123; for (EditLayout layout : allItems) &#123; editLayout.close(); &#125;&#125;/** * 将所有 item 向左展开 */public void openLeftAll() &#123; for (EditLayout layout : allItems) &#123; editLayout.openLeft(); &#125;&#125; EditRecyclerView当列表有某一项是右边展开了，我希望在滑动列表的时候能将它关闭，变回向左展开的状态，所以我自定义了一个 RecyclerView。 可以重写了 onTouchEvent 方法，实现上面说的效果： 12345678910111213@Overridepublic boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_DOWN: if (getAdapter() instanceof EditAdapter) &#123; rightOpenItem = ((EditAdapter) getAdapter()).getRightOpenItem(); &#125; if (EditAdapter.isEdit &amp;&amp; rightOpenItem != null) &#123; rightOpenItem.openLeft(); &#125; &#125; return super.onTouchEvent(e);&#125; 当滑动列表的时候，先判断是否有向右展开项，有的话就将它变回向左展开。 这样就完成啦，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[浪起来！使用 drawBitmapMesh 实现仿真水波纹效果]]></title>
      <url>%2F2017%2F04%2F22%2F201704221946%2F</url>
      <content type="text"><![CDATA[在 Android 的画布 Canvas 里面有个 drawBitmapMesh 方法，通过它可以实现对 Bitmap 的各种扭曲。我们试一下用它把图像扭出水波纹的效果。 和 Material Design 里扁平化的水波纹不同，这里是通过对图像的处理，模拟真实的水波纹效果，最后实现的效果如下： drawBitmapMesh 简介我们先了解一下「网格」的概念。 将一个图片横向、纵向均匀切割成 n 份，就会形成一个「网格」，我把所有网格线的交点称为「顶点」。 正常情况下，顶点是均匀分布的。当我们改变了顶点的位置时，系统会拿偏移后的顶点坐标，和原来的坐标进行对比，通过一套算法，将图片进行扭曲，像这样： 接下来看看 drawBitmapMesh 方法： 12345678public void drawBitmapMesh(Bitmap bitmap, int meshWidth, int meshHeight, float[] verts, int vertOffset, int[] colors, int colorOffset, Paint paint) 它的参数如下： bitmap - 需要转换的位图 meshWidth - 横向的格数，需大于 0 meshHeight - 纵向的格数，需大于 0 verts - 网格顶点坐标数组，记录扭曲后图片各顶点的坐标，数组大小为 (meshWidth+1) (meshHeight+1) 2 + vertOffset vertOffset - 从第几个顶点开始对位图进行扭曲，通常传 0 colors - 设置网格顶点的颜色，该颜色会和位图对应像素的颜色叠加，数组大小为 (meshWidth+1) * (meshHeight+1) + colorOffset，可以传 null colorOffset - 从第几个顶点开始转换颜色，通常传 0 paint - 「画笔」，可以传 null 需要说明一下的是，可以用 colors 这个参数来实现阴影的效果，但在 API 18 以下开启了硬件加速，colors 这个参数是不起作用的。我们这里只关注前面四个参数，后面四个传 0、null、0、null 就可以了。 创建 RippleLayout创建自定义控件 RippleLayout，为了让控件用起来更灵活，我让它继承了 FrameLayout（套上哪个哪个浪！）。 定义了如下成员变量： 12345678910111213141516171819//图片横向、纵向的格数private final int MESH_WIDTH = 20;private final int MESH_HEIGHT = 20;//图片的顶点数private final int VERTS_COUNT = (MESH_WIDTH + 1) * (MESH_HEIGHT + 1);//原坐标数组private final float[] staticVerts = new float[VERTS_COUNT * 2];//转换后的坐标数组private final float[] targetVerts = new float[VERTS_COUNT * 2];//当前控件的图片private Bitmap bitmap;//水波宽度的一半private float rippleWidth = 100f;//水波扩散速度private float rippleSpeed = 15f;//水波半径private float rippleRadius;//水波动画是否执行中private boolean isRippling; 看注释就知道什么意思啦，下面会用到的。 然后又定义了一个这里会经常用到的方法，根据宽高计算对角线的距离（勾股定理）： 12345678910/** * 根据宽高，获取对角线距离 * * @param width 宽 * @param height 高 * @return 距离 */private float getLength(float width, float height) &#123; return (float) Math.sqrt(width * width + height * height);&#125; 获取 Bitmap要处理 Bitmap，第一步当然是先拿到 Bitmap，拿到后就可以根据 Bitmap 的宽高初始化两个顶点坐标数组： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 初始化 Bitmap 及对应数组 */private void initData() &#123; bitmap = getCacheBitmapFromView(this); if (bitmap == null) &#123; return; &#125; float bitmapWidth = bitmap.getWidth(); float bitmapHeight = bitmap.getHeight(); int index = 0; for (int height = 0; height &lt;= MESH_HEIGHT; height++) &#123; float y = bitmapHeight * height / MESH_HEIGHT; for (int width = 0; width &lt;= MESH_WIDTH; width++) &#123; float x = bitmapWidth * width / MESH_WIDTH; staticVerts[index * 2] = targetVerts[index * 2] = x; staticVerts[index * 2 + 1] = targetVerts[index * 2 + 1] = y; index += 1; &#125; &#125;&#125;/** * 获取 View 的缓存视图 * * @param view 对应的View * @return 对应View的缓存视图 */private Bitmap getCacheBitmapFromView(View view) &#123; view.setDrawingCacheEnabled(true); view.buildDrawingCache(true); final Bitmap drawingCache = view.getDrawingCache(); Bitmap bitmap; if (drawingCache != null) &#123; bitmap = Bitmap.createBitmap(drawingCache); view.setDrawingCacheEnabled(false); &#125; else &#123; bitmap = null; &#125; return bitmap;&#125; 计算偏移坐标接下来是重点了。这里要实现的水波的位置在下图的灰色区域： 我定义了一个 warp 方法，根据手指按下的坐标（原点）来重绘 Bitmap： 1234567891011121314151617181920212223/** * 图片转换 * * @param originX 原点 x 坐标 * @param originY 原点 y 坐标 */private void warp(float originX, float originY) &#123; for (int i = 0; i &lt; VERTS_COUNT * 2; i += 2) &#123; float staticX = staticVerts[i]; float staticY = staticVerts[i + 1]; float length = getLength(staticX - originX, staticY - originY); if (length &gt; rippleRadius - rippleWidth &amp;&amp; length &lt; rippleRadius + rippleWidth) &#123; PointF point = getRipplePoint(originX, originY, staticX, staticY); targetVerts[i] = point.x; targetVerts[i + 1] = point.y; &#125; else &#123; //复原 targetVerts[i] = staticVerts[i]; targetVerts[i + 1] = staticVerts[i + 1]; &#125; &#125; invalidate();&#125; 方法里面遍历了所有的顶点，如果顶点是在水波范围内，则需要对这个顶点进行偏移。 偏移后的坐标计算，思路大概是这样的： 为了让水波有突起的感觉，以水波中间（波峰）为分界线，里面的顶点往里偏移，外面的顶点往外偏移： 至于偏移的距离，我想要实现类似放大镜的效果，离波峰越近的顶点，偏移的距离会越大。离波峰的距离和偏移距离的关系，可以看作一个余弦曲线： 我们来看一下 getRipplePoint 方法，传入的参数是原点的坐标及需要转换的顶点坐标，在它里面做了下面这些处理： 通过反正切函数获取到顶点和原点间的水平角度： 1float angle = (float) Math.atan(Math.abs((staticY - originY) / (staticX - originX))); 通过余弦函数计算顶点的偏移距离： 123float length = getLength(staticX - originX, staticY - originY);float rate = (length - rippleRadius) / rippleWidth;float offset = (float) Math.cos(rate) * 10f; 这里的 10f 是最大偏移距离。 计算出来的偏移距离是直线距离，还需要根据顶点和原点的角度，用余弦、正弦函数将它转换成水平、竖直方向的偏移距离： 12float offsetX = offset * (float) Math.cos(angle);float offsetY = offset * (float) Math.sin(angle); 根据顶点原来的坐标和偏移量就可以得出偏移后的坐标了，至于是加还是减，还要看顶点所在的位置。 getRipplePoint 的完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 获取水波的偏移坐标 * * @param originX 原点 x 坐标 * @param originY 原点 y 坐标 * @param staticX 待偏移顶点的原 x 坐标 * @param staticY 待偏移顶点的原 y 坐标 * @return 偏移后坐标 */private PointF getRipplePoint(float originX, float originY, float staticX, float staticY) &#123; float length = getLength(staticX - originX, staticY - originY); //偏移点与原点间的角度 float angle = (float) Math.atan(Math.abs((staticY - originY) / (staticX - originX))); //计算偏移距离 float rate = (length - rippleRadius) / rippleWidth; float offset = (float) Math.cos(rate) * 10f; float offsetX = offset * (float) Math.cos(angle); float offsetY = offset * (float) Math.sin(angle); //计算偏移后的坐标 float targetX; float targetY; if (length &lt; rippleRadius + rippleWidth &amp;&amp; length &gt; rippleRadius) &#123; //波峰外的偏移坐标 if (staticX &gt; originY) &#123; targetX = staticX + offsetX; &#125; else &#123; targetX = staticX - offsetX; &#125; if (staticY &gt; originY) &#123; targetY = staticY + offsetY; &#125; else &#123; targetY = staticY - offsetY; &#125; &#125; else &#123; //波峰内的偏移坐标 if (staticX &gt; originY) &#123; targetX = staticX - offsetX; &#125; else &#123; targetX = staticX + offsetX; &#125; if (staticY &gt; originY) &#123; targetY = staticY - offsetY; &#125; else &#123; targetY = staticY + offsetY; &#125; &#125; return new PointF(targetX, targetY);&#125; 我也不知道这种计算方法是否符合物理规律，反正感觉像那么回事。 执行水波动画大家都知道事件分发机制，作为一个 ViewGroup，会先执行 dispatchTouchEvent 方法。我在事件分发之前执行水波动画，也保证了事件传递不受影响： 123456789@Overridepublic boolean dispatchTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: showRipple(ev.getX(), ev.getY()); break; &#125; return super.dispatchTouchEvent(ev);&#125; showRipple 的任务就是循环执行 warp 方法，并且不断改变水波半径，达到向外扩散的效果： 123456789101112131415161718192021222324252627282930313233/** * 显示水波动画 * * @param originX 原点 x 坐标 * @param originY 原点 y 坐标 */public void showRipple(final float originX, final float originY) &#123; if (isRippling) &#123; return; &#125; initData(); if (bitmap == null) &#123; return; &#125; isRippling = true; //循环次数，通过控件对角线距离计算，确保水波纹完全消失 int viewLength = (int) getLength(bitmap.getWidth(), bitmap.getHeight()); final int count = (int) ((viewLength + rippleWidth) / rippleSpeed); Observable.interval(0, 10, TimeUnit.MILLISECONDS) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .take(count + 1) .subscribe(new Consumer&lt;Long&gt;() &#123; @Override public void accept(@NonNull Long aLong) throws Exception &#123; rippleRadius = aLong * rippleSpeed; warp(originX, originY); if (aLong == count) &#123; isRippling = false; &#125; &#125; &#125;);&#125; 这里用了 RxJava 2 实现循环，循环的次数是根据控件的对角线计算的，保证水波会完全消失。水波消失后再点击才会执行下一次的水波动画。 注意！要点题了。 讲了这么多还没用到 drawBitmapMesh 方法。ViewGroup 绘制子控件的方法是 dispatchDraw，warp 方法最后调用的 invalidate() 也会触发 dispatchDraw 的执行，所以可以在这里做手脚： 12345678@Overrideprotected void dispatchDraw(Canvas canvas) &#123; if (isRippling &amp;&amp; bitmap != null) &#123; canvas.drawBitmapMesh(bitmap, MESH_WIDTH, MESH_HEIGHT, targetVerts, 0, null, 0, null); &#125; else &#123; super.dispatchDraw(canvas); &#125;&#125; 如果是自定义 View 的话，要修改 onDraw 方法。 到这就完成啦。妥妥的。 对了，不建议用这个控件包裹可滑动或者有动画的控件，因为在绘制水波的时候，子控件的变化都是看不到的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我把 Toolbar 转了一下变成了菜单]]></title>
      <url>%2F2017%2F04%2F13%2F201704132119%2F</url>
      <content type="text"><![CDATA[侧滑菜单我们见的太多了，有没有想过有别的方式弹出菜单？比如，让 Toolbar 变成菜单？ 我也不知道怎么描述这个效果了，直接放效果图吧： 炸不炸！ 其实实现起来超简单。 思路看上去好像 Toolbar 变成了菜单，但大家也能猜到，这里面的旋转菜单其实和 Toolbar 是两个控件，左上角的菜单按钮也是也是两个按钮，只不过在同样的位置放了同样的图片。 所以我自定义了一个旋转控件 SpringRotateMenu，继承 FrameLayout，在这里面实现旋转动画及手势操作。 旋转动画Gif 图可能不明显，菜单展开和收起的时候是会抖一下的，有一种「DUANG」的感觉。是不是有种弹簧的感觉？没错，我用的就是新出的弹簧动画（SpringAnimation）。 关于 SpringAnimation，我之前的这篇会有更详细的介绍： 实现一个带下拉弹簧动画的 ScrollView SpringAnimation 支持平移、缩放、旋转等效果，这次我们用到的是它的旋转效果。 我们先定义展开和收起状态的两个角度： 12private final static int ROTATE_EXPAND = 0;private final static int ROTATE_COLLAPSE = -90; 然后这样来获取旋转弹簧动画： 12expandAnimation = new SpringAnimation(this, SpringAnimation.ROTATION, ROTATE_EXPAND);collapseAnimation = new SpringAnimation(this, SpringAnimation.ROTATION, ROTATE_COLLAPSE); 需要注意的是第三个参数。在平移动画里面，第三个参数是偏移量，而在旋转动画里面代表的是度数。在这里我定义了展开动画（旋转到0°）及收起动画（旋转到 -90°）。 然后提供两个方法来设置展开和收起的按钮： 1234567891011121314151617181920212223/** * 设置展开按钮 */public void setExpandButton(View expandButton) &#123; expandButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; expand(); &#125; &#125;);&#125;/** * 设置折叠按钮 */public void setCollapseButton(View collapseButton) &#123; collapseButton.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; collapse(); &#125; &#125;);&#125; 展开按钮就是 Toolbar 上的按钮，收起按钮则是菜单上的按钮。 展开、收起的方法也很简单： 123456789101112131415161718192021222324252627282930313233343536373839/** * 展开菜单 */public void expand() &#123; setVisibility(VISIBLE); expandAnimation.start(); if (listener != null) &#123; listener.expandBegin(); collapseAnimation.addEndListener(new DynamicAnimation.OnAnimationEndListener() &#123; @Override public void onAnimationEnd(DynamicAnimation animation, boolean canceled, float value, float velocity) &#123; setVisibility(INVISIBLE); listener.expandEnd(); &#125; &#125;); &#125;&#125;/** * 折叠菜单 */public void collapse() &#123; collapseAnimation.start(); if (listener != null) &#123; listener.collapseBegin(); collapseAnimation.addEndListener(new DynamicAnimation.OnAnimationEndListener() &#123; @Override public void onAnimationEnd(DynamicAnimation animation, boolean canceled, float value, float velocity) &#123; listener.collapseEnd(); &#125; &#125;); &#125;&#125; 其实就是让对应的动画执行，菜单在开始展开的时候显示，在完全收起的时候隐藏。至于这里的 listener 是我加的一个动画监听器，监听两个动画的开始和结束，供外部使用。 手势操作手势操作就是重写 onTouchEvent，代码如下： 1234567891011121314151617181920212223242526272829303132333435private float mDownX;@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; if (expandAnimation.isRunning() || collapseAnimation.isRunning()) &#123; return super.onTouchEvent(event); &#125; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = event.getRawX(); break; case MotionEvent.ACTION_MOVE: //滑动距离 float deltaX = event.getRawX() - mDownX; //设置角度 float rotation = (deltaX / (screenWidth * 0.8f)) * ROTATE_COLLAPSE; if (rotation &lt;= ROTATE_EXPAND &amp;&amp; rotation &gt;= ROTATE_COLLAPSE) &#123; setRotation(rotation); &#125; else if (rotation &gt; ROTATE_EXPAND) &#123; setRotation(ROTATE_EXPAND); &#125; else if (rotation &lt; ROTATE_COLLAPSE) &#123; setRotation(ROTATE_COLLAPSE); &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: if (getRotation() &lt; ROTATE_COLLAPSE / 3) &#123; collapse(); &#125; else &#123; expand(); &#125; break; &#125; return true;&#125; 核心就是将手指的横向滑动距离转换为旋转角度。我的计算方法是，菜单控件的旋转角度，等于横向滑动距离占屏幕宽度的比例，乘以 -90°。至于为什么宽度要乘以 0.8，我是为了让手指在屏幕上滑过 80% 的宽度，就可以将菜单完全收起。 还有就是手指抬起时的处理。我觉得在用户向右滑动菜单时，大部分情况下是希望将菜单收起的，应该让它更容易收起。所以我的做法是，当手指抬起时，菜单竖直的角度超过 30°，就让它执行收起的动画，否则执行展开的动画。 使用布局使用 SpringRotateMenu 作为旋转菜单的根布局，并设置控件的旋转中心点。默认的 Toolbar 高度为 56dp，如果菜单按钮居中显示的话，可以使用： 12android:transformPivotX=&quot;28dp&quot;android:transformPivotY=&quot;28dp&quot; 然后用 FrameLayout 将它覆盖在 Toolbar 上面。 建议让菜单布局的背景颜色和 Toolbar 的颜色一致，并使用同一个菜单图标，菜单图标里面加一个参数： 1android:rotation=&quot;90&quot; 让图标旋转九十度。 代码在代码里面找到我们的 SpringRotateMenu，然后简单的设置一下，比如这样： 123456789101112131415161718192021222324springRotateMenu.setExpandButton(findViewById(R.id.iv_menu));springRotateMenu.setCollapseButton(springRotateMenu.findViewById(R.id.iv_menu));springRotateMenu.setAnimationListener(new SpringRotateMenu.OnAnimationListener() &#123; @Override public void expandBegin() &#123; toolbar.setVisibility(View.INVISIBLE); &#125; @Override public void expandEnd() &#123; &#125; @Override public void collapseBegin() &#123; &#125; @Override public void collapseEnd() &#123; toolbar.setVisibility(View.VISIBLE); &#125;&#125;); 这样就完成啦，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在 Android Studio 上调试数据库 ( SQLite )]]></title>
      <url>%2F2017%2F04%2F02%2F201704021829%2F</url>
      <content type="text"><![CDATA[以前 Eclipse 时代，调试 SQLite 都是将数据库文件导出到电脑，然后再用软件打开查看。现在我们用 Android Studio，有没有更方便的方法呢？ SQLScout安装SQLScout 是一个 Android Studio 的插件，通过点击： Setting —&gt; Plugings —&gt; Browse Repositories 搜索 SQLScout 安装即可。 要是下载不动，可以到这里下载，然后点击 Install plugin from disk 导入。 加载成功安装后重启 Android Studio，会发现右边的侧边栏出现了 SQLite Exporer，展开后点击「+」会出现三个选项： 我们从下往上说吧。 Local SQLite Database如果要调试的数据库已经导出在电脑里了，就选择这一项来加载。 Android (Download Database Locally)通常情况下，我们要调试的数据库是在手机上的，可以用这个功能把数据库提取出来。选择需要调试的设备、项目包名及数据库名就可以了。 Android (Live Device Connection)上面两种方法的缺点很明显，都无法实时更新数据库。 Live Device Connection 是 SQLScout 2.0 新增的功能，和上面的区别是，它可以实时管理、更新数据库。 使用之前需要在在 project 的 build.gradle 里面添加： 12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url 'http://www.idescout.com/maven/repo/' &#125; &#125;&#125; 在 module 的 build.gradle 里面添加： 1compile 'com.idescout.sql:sqlscout-server:2.0' 在启动的 Activity 的 onCreate 方法添加一句代码： 1SqlScoutServer.create(this, getPackageName()); 调试整个界面如下： 它们分别是： 数据库列表：要调试的数据库列表，展开显示数据库中的表，可以右键打开 SQL 编辑器。 SQL 编辑器：输入 SQL 语句的地方，支持自动补全及代码高亮。 数据控制台：用类似 Excel 的格式展示查询的数据，也可以在这里编辑数据。 数据关系图：用于展示表和字段的关系。 是不是很好用，简直就是神器啊！但这么好用的东西是收费的。 穷屌丝用不起怎么办？接着往下看啊。 Android Debug Database这是一个开源的项目（免费），项目地址在这。 先在 module 的 build.gradle 里面添加： 1debugCompile 'com.amitshekhar.android:debug-db:1.0.0' 让手机和电脑处于一个局域网下，当项目跑起来的时候，在 logcat 里面会打印出这么一行： 1D/DebugDB: Open http://XXX.XXX.X.XXX:8080 in your browser 把地址复制到浏览器，就会看到一个这样的界面： 很容易理解，里面几个栏目分别是： Query：写 SQL 语句的地方 Databases：数据库 Tables：数据库中的表 Data：表中的数据，支持编辑、搜索 就是这么简单，妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现一个带下拉弹簧动画的 ScrollView]]></title>
      <url>%2F2017%2F03%2F25%2F201703251208%2F</url>
      <content type="text"><![CDATA[在刚推出的 Support Library 25.3.0 里面新增了一个叫 SpringAnimation 的动画，也就是弹簧动画。要是用它来做一个滑动控件下拉回弹的效果，应该不错吧。 SpringAnimation开始之前，别忘了在 app 的 build.gradle 加上： compile ‘com.android.support:appcompat-v7:25.3.0’compile ‘com.android.support:design:25.3.0’compile ‘com.android.support:support-dynamic-animation:25.3.0’ 然后我们看看 SpringAnimation 的基本用法，首先是它的构造方法： 12345public SpringAnimation(View v, ViewProperty property, float finalPosition) &#123; super(v, property); mSpring = new SpringForce(finalPosition); setSpringThreshold();&#125; 看命名可以大概猜到参数的意义了： v - 要执行动画的控件 property - 动画的性质，可以选择平移、缩放、旋转等 finalPosition - 动画结束时，控件所在位置的坐标偏移量 这里实现的滑动控件是上下滑动的，所以我们这样来获取 SpringAnimation ： 1springAnim = new SpringAnimation(this, SpringAnimation.TRANSLATION_X, 0); SpringAnimation 里面有两个比较重要的属性，分别是： Stiffness - 刚度，值越大回弹的速度越快，类似于劲度系数，默认值是 1500f DampingRatio - 阻尼，值越小，回弹后，动画来回的次数越多，就是更有「DUANG」的感觉，默认值是 0.5f 通过 1springAnim.getSpring().setStiffness(float stiffness) 和1springAnim.getSpring().setDampingRatio(float dampingRatio) 来设置上面两个属性。 再调用 springAnim.start() 就可以开始动画啦。 SpringScrollView我们自定义一个 SpringScrollView 继承 NestedScrollView，重写 onTouchEvent 方法让它有回弹的效果： 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_MOVE: if (getScrollY() &lt;= 0) &#123; //顶部下拉 if (startDragY == 0) &#123; startDragY = e.getRawY(); &#125; if (e.getRawY() - startDragY &gt; 0) &#123; setTranslationY((e.getRawY() - startDragY) / 3); return true; &#125; else &#123; springAnim.cancel(); setTranslationY(0); &#125; &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: if (getTranslationY() != 0) &#123; springAnim.start(); &#125; startDragY = 0; break; &#125; return super.onTouchEvent(e);&#125; 简单解释一下哈。 当 ScrollView 在顶部时，记录下手指所在的 y 轴位置。在顶部并且是往下滑动的时候，给 ScrollView 设置一个纵向的偏移。之所以除以 3，是为了让控件有种要用力才能拖动的感觉。 在顶部的时候如果是往上滑动，则把动画效果取消，把控件位置复原，否则可能出现控件一直偏移的情况。 最后当手指抬起时，执行弹簧动画就好了。 为什么这里用 getRawY() 获取坐标，而不是用 getY() 来获取。因为 getY() 是相对于控件的坐标，当设置了 TranslationY 之后会改变它的值，也就是在滑动的时候 getY() 的值是不连续的，会出现卡顿的现象。而 getRawY() 是相对于屏幕的位置，管你控件怎么动，屏幕都是固定的。 下拉回弹的效果就已经完成了。对了，我们顺便把底部上拉的回弹也做一下呗。由于ScrollView只有一个子布局，所以可以通过 1getScrollY() + getHeight()) &gt;= getChildAt(0).getMeasuredHeight() 判断是否滑动到了底部。 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class SpringScrollView extends NestedScrollView &#123; private float startDragY; private SpringAnimation springAnim; public SpringScrollView(Context context) &#123; this(context, null); &#125; public SpringScrollView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SpringScrollView(Context context, @Nullable AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); springAnim = new SpringAnimation(this, SpringAnimation.TRANSLATION_Y, 0); //刚度 默认1200 值越大回弹的速度越快 springAnim.getSpring().setStiffness(800.0f); //阻尼 默认0.5 值越小，回弹之后来回的次数越多 springAnim.getSpring().setDampingRatio(0.50f); &#125; @Override public boolean onTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_MOVE: if (getScrollY() &lt;= 0) &#123; //顶部下拉 if (startDragY == 0) &#123; startDragY = e.getRawY(); &#125; if (e.getRawY() - startDragY &gt; 0) &#123; setTranslationY((e.getRawY() - startDragY) / 3); return true; &#125; else &#123; springAnim.cancel(); setTranslationY(0); &#125; &#125; else if ((getScrollY() + getHeight()) &gt;= getChildAt(0).getMeasuredHeight()) &#123; //底部上拉 if (startDragY == 0) &#123; startDragY = e.getRawY(); &#125; if (e.getRawY() - startDragY &lt; 0) &#123; setTranslationY((e.getRawY() - startDragY) / 3); return true; &#125; else &#123; springAnim.cancel(); setTranslationY(0); &#125; &#125; break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: if (getTranslationY() != 0) &#123; springAnim.start(); &#125; startDragY = 0; break; &#125; return super.onTouchEvent(e); &#125;&#125; 最后看看效果吧： 同样的思路也可以用在别的滑动控件里面。 妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[说一说世界上最贵的几幅画（纯属扯淡）]]></title>
      <url>%2F2017%2F03%2F18%2F201703181630%2F</url>
      <content type="text"><![CDATA[闲着没事，给大家扯一下世界上最贵的几幅画。 前言提到世界名画，大家可能会想到下面这些。 但这些都不属于我今天的讨论范围，为什么？ 如果你去故宫看到一个瓶子挺漂亮的，然后你问那里的工作人员“这瓶子怎么卖？”，他会告诉你： 不卖！！！ 所以我今天讨论的画都是真实成交了的，是世界上成交价格最贵的几幅。 嘉舍医生的肖像我们先来看看这幅画的作者，这是作者的自画像。 你可能觉得验收但不认识，但你肯定听说过他的名字—梵高！ 讲一个梵高的小故事，梵高曾经和他的一个好基友住在一个叫阿尔勒的地方。就是这里： 这幅画也是梵高画的，他的向日葵也是在这个时期画的。 某天梵高的好基友发现梵高是个神经病，然后就不跟他玩，就搬走了。事实上，梵高确实是个神经病，准确说是一个精神病患者。他的好基友走之后，他伤心欲绝，把自己的耳朵割了下来，然后他就变成了这样： 在之后的一段时间，梵高在他弟弟的安排下接受了精神病医生的治疗，这名医生就是嘉舍医生。嘉舍医生给梵高的鉴定结果是什么病都没有，梵高知道这个鉴定结果后跟他弟弟说「这家伙比我病的还厉害」。其实，嘉舍医生确实患有抑郁症，但他是个艺术爱好者，很快和梵高也成了好朋友。梵高给他画了一张肖像画。 梵高说： 我希望画一位艺术家友人的肖像，他满怀伟大的理想。我希望把我对这个人的感觉和爱慕之心画进作品里。我夸张了他的头发的金黄色，在头像后面我不画小屋的普通墙壁，而用我调配得极为丰富、极为强烈的蓝色涂出无限深远的背景。由于这种单纯的配合，使金黄色头发的头部，在这丰富的蓝色背景上发光，像星星嵌在深沉的碧空中。 画下这幅画的一个月后,梵高自杀了。 在拍卖这幅画的时候，开拍没多久，一个日本人就喊出了一个让全场人都吓尿的价格： 8250 万美元!!! 购得这幅画的是一个日本人，是一家造纸公司的老板，他死后，这幅画就下落不明了。 猫王八重影我们同样先来认识一下作者，他名叫安迪·沃霍尔。 某一天，沃霍尔突然才思泉涌，灵感大爆发。对着猫王 Ctrl + C，然后又按了两下 Ctrl + V，于是一幅杰作诞生了： 猫王三重影！！！ 你可能觉得这画好像没什么厉害的，但是它的厉害之处在于——卖出了8190万美元！ 某天沃霍尔灵机一动，又多按了几下 Ctrl + V，于是又一幅杰作诞生了 猫王八重影！！！ 据说，猫王八重影卖给了某位卡塔尔皇室成员。成交价是： 一亿美元！！！ 没有欣赏水平的我在网上搜索了一下相关的评论： 单调、无聊和重复，所传达的是某种冷漠、空虚、疏离的感觉，表现了当代高度发达的商业文明社会中人们内在的感情。 好吧，还是欣赏不来。值得一提的是，沃霍尔创作过这样一个系列，其中一幅在英国卖了 760 万英镑。 呐喊下面这幅画大家都有看过，作者是爱德华·蒙克。 一天傍晚，我和朋友走在路上，一边是城市，另一边是脚下的峡湾，我感到浑身不舒服。我停下来眺望峡湾，落日将云彩染成血一般鲜红。就在那时，我想我听到了大自然不停地尖叫。于是，我画了这幅画—将云彩画得像真正的鲜血，让色彩去吼叫。 这段话是蒙克说的关于这幅画的创作背景。我觉得这幅画应该翻译成尖叫更贴切。 这幅画所描绘的地点被人肉出来了，是挪威的一条山路。 有趣的是过去在这里附近有一个屠宰场，还有一个精神病院，所以作者当时听到的声音很可能是从屠宰场或者精神病院发出来的。 大家可能不知道，呐喊一共有四个版本。 其中 1895 年的这个版本，在 2012 年纽约以 1.19 亿美元成交。 我想再聊一下最早的这个 1893 年的版本。 1994 年 2 月 12 日，也就是挪威冬奥会开幕当天，挪威国家美术馆将「呐喊」转移到了另外一个展厅，以供展出。然后它就被偷了！第二年才被完好的追回。 2004 年 8 月 22 日（这个日期和蒙娜丽莎被偷的日期是一样的），一伙蒙面持枪者在众目睽睽之下进入蒙克博物馆。然后「呐喊」又被偷了！这张照片是当时路人拍到的，两个犯人正把画搬到自己车上。 直到两年后画才被找回，但是警方也没有说是怎么找回的，现在这幅画保存在蒙克博物馆。 阿黛拉这幅画的作者是克林姆特 这张照片看上去很文艺，其实他是个有点猥琐的人。 这是他的阿黛拉： 关于这幅画，有人把称它为「奥地利的蒙娜丽莎」，可见它的艺术地位之高。这幅画以 1.35 亿美元成交，买它的人是当时雅诗兰黛的老板，他人比较大方，把这幅画无期限的借给了纽约新画廊展出。在这幅画在纽约展出的第一年，去纽约旅游的人数增加了 20%。 大家看这幅画是不是感觉金光闪闪的，像金子一样，事实上这就是真的金子，是用金箔贴上去的，用料还是比较足的。 有关这幅画，大家有兴趣的可以看一下这部电影，叫金衣女人，讲诉了关于这幅画在近代发生的故事，是真实事件改编的。 女人 3 号 这幅画的作者叫库宁，卖了 1.375 亿美元。 关于这幅画，其实我纯粹就是想吐槽一下。这幅画画的是库宁的老婆，你肯定会想：怎么会有人把自己老婆画成这个鬼样！因为当时他老婆出轨了。所以说不要轻易得罪艺术家，不然一不小心就变成一幅世界名画了，还是以这样的形象。 你何时结婚？这是最后一幅了。还记不记得我前面说的，梵高之前跟一个好基友住一起，后来那个好基友跑了，导致梵高把耳朵割掉。这就是那个好基友，叫高更。 高更的一生充满传奇色彩，他年轻时当过水手，周游过世界，后来还当过股票经纪人，炒过股。然后突然有一天，不知道是不是他股票亏太多了，他突然说： 我想摆脱文明的影响，我只想从事非常质朴的艺术。为此我需要沉浸在未被开发的大自然中，无忧无虑，像孩童一样。借助原始艺术提供的唯一方法，描绘我大脑中的一切观念。这才是独一无二的美好真实的艺术。 然后他去了一个原始社会——塔希提岛，现在这里叫大溪地。高更在这里找到了他要的一切——脱离文明社会、有着壮观的景色、原始的自然，这里人还过着原始生活。还有这里的女人长的漂亮，还经常不穿衣服。所以据说高更在那里过上了很幸福的生活。 这是高更在岛上画的画中的一幅，叫你何时结婚，这幅画是目前艺术品成交价格最高的记录保持着，大家猜一下它卖了多少钱？ 三亿美元！ 据说是给一个卡塔尔博物馆买走了。 总结上面这些画虽然千奇百怪，但是他们有一个共同点：有个性！ 知道这些有什么用？如果以后大家有机会去美术馆，就可以装一下了。 看到线条扭曲，颜料像不要钱一样往上面抹的，就是梵高的作品。 看到拿某个名人复制粘贴的就是沃霍尔。 线条很夸张，让人感觉很压抑的，就是蒙克。 往画上面贴金的，是克林姆特。 画了一个丑女人的，是库宁。 在一片原始森林里，有几个黑女人的，是高更。 妥妥的。 就到这吧，谢谢大家看我扯淡。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[像 QQ 一样处理滑动冲突]]></title>
      <url>%2F2017%2F03%2F12%2F201703121142%2F</url>
      <content type="text"><![CDATA[在项目中，如果要用到滑动控件嵌套滑动控件，总会让人很心塞。因为很可能会出现冲突的问题。这里举个例子，利用事件分发机制，处理侧滑菜单控件和列表中的侧滑删除控件间的冲。 分析提到侧滑删除，一个经典的例子就是 QQ 了。QQ 的首页是一个大的侧滑菜单控件，嵌套一个列表，列表里面再嵌套侧滑删除的控件。我们就仿照这个样式，看看能不能做一个和它类似的效果。 这里关注的重点是在滑动手势的处理上，简单分析一下需要做什么处理： （下面把侧滑菜单控件称作菜单控件，列表侧滑删除控件称作删除控件。） 在首页上下滑动时，滚动列表。 菜单控件关闭的情况下，如果列表里面没有展开的删除项，则手指向右滑动是滑动菜单控件，向左滑动是滑动删除控件。 如果列表里面有展开的删除控件，则菜单控件和列表项都不可滑动。除了删除按键，点击其他区域，都是将展开项关闭。 当手指滑动删除控件时，手指滑动到屏幕的任意区域都可以滑动展开项。 菜单控件打开的情况下，点击右边主页区域，将菜单控件关闭。 有点复杂的感觉啊，我们一个个来解决。 我自定义了上面说到的三个控件，根据嵌套关系，从大到小分别是： 菜单控件 SwipeMenuLayout 列表控件 MyRecyclerView 删除控件 SwipeDeleteLayout 其中，SwipeMenuLayout 和 SwipeDeleteLayout 都是继承自 FrameLayout，用 ViewDragHelper 实现滑动效果。MyRecyclerView 则继承自 RecyclerView。 我们知道事件分发和三个方法有关： 负责分发的 dispatchTouchEvent 负责拦截的 onInterceptTouchEvent 负责消费的 onTouchEvent 简单概括一下这个机制就是：分发从父到子，消费从子到父。 一般我们不对分发做特殊处理，下面按执行顺序看看三个控件的 onInterceptTouchEvent 和 onTouchEvent 方法是怎么写的。 onInterceptTouchEventonInterceptTouchEvent 方法的返回值决定是否拦截事件。 菜单控件这部分要稍微啰嗦一点。我们先看看菜单关闭的情况，这时如果手指向右滑且没有展开的删除控件，我们就可以把事件拦截了，所以 onInterceptTouchEvent 可以写成这样： 123456789101112131415161718192021if (mState == State.CLOSE) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mDownX = ev.getRawX(); mDownY = ev.getRawY(); &#125; break; case MotionEvent.ACTION_MOVE: &#123; float deltaX = ev.getRawX() - mDownX; float deltaY = ev.getRawY() - mDownY; //向右滑动且列表没有展开项且横向滑动距离比竖向滑动距离大，则拦截 if (deltaX &gt; 0 &amp;&amp; MainAdapter.mOpenItems.size() == 0 &amp;&amp; Math.abs(deltaY / deltaX) &lt; 1) &#123; return true; &#125; &#125; break; &#125;&#125; mState 代表当前侧滑控件的状态，MainAdapter.mOpenItems 保存的是当前打开的删除控件。我使用 Math.abs(deltaY / deltaX) 是否小于 1 来判断手指的滑动方向。 这里还有两种不拦截的情况，向左滑动或者有展开项的话，都是和侧滑菜单没关系的，滑动事件里面再加入以下代码： 123456//如果是向左滑，且竖直滑动距离大于横向滑动距离，不拦截//MainPage打开的item个数大于0，不拦截if ((deltaX &lt; 0 &amp;&amp; Math.abs(deltaY / deltaX) &gt; 1) || MainAdapter.mOpenItems.size() &gt; 0) &#123; return false;&#125; 接下来是菜单打开的情况。这时候当手指点击了右侧的主页面区域是需要拦截并且将菜单关闭。如果手指向右滑动则不需要拦截： 123456789101112131415161718if (mState == State.OPEN) &#123; //完全展开时并且点到主页面，拦截并关闭菜单 if (mMainContent.getLeft() &lt;= mRange &amp;&amp; ev.getRawX() &gt; mRange) &#123; return true; &#125; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = ev.getRawX(); break; case MotionEvent.ACTION_MOVE: //如果是向右滑，不拦截 float deltaX = ev.getRawX() - mDownX; if (deltaX &gt; 0) &#123; return false; &#125; break; &#125;&#125; mRange是侧滑出来的菜单宽度，关闭菜单的操作可以放在 ViewDragHelper 的 Callback 方法处理。 除了上面这些情况，默认情况下是否拦截交给 ViewDragHelper 处理就好了，调用它的 shouldInterceptTouchEvent 方法。 完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public boolean onInterceptTouchEvent(MotionEvent ev) &#123; if (mState == State.CLOSE) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; mDownX = ev.getRawX(); mDownY = ev.getRawY(); &#125; break; case MotionEvent.ACTION_MOVE: &#123; float deltaX = ev.getRawX() - mDownX; float deltaY = ev.getRawY() - mDownY; //向右滑动且列表没有展开项且横向滑动距离比竖向滑动距离大，则拦截 if (deltaX &gt; 0 &amp;&amp; MainAdapter.mOpenItems.size() == 0 &amp;&amp; Math.abs(deltaY / deltaX) &lt; 1) &#123; return true; &#125; //如果是向左滑，且竖直滑动距离大于横向滑动距离，不拦截 //MainPage打开的item个数大于0，不拦截 if ((deltaX &lt; 0 &amp;&amp; Math.abs(deltaY / deltaX) &gt; 1) || MainAdapter.mOpenItems.size() &gt; 0) &#123; return false; &#125; &#125; break; &#125; &#125; else if (mState == State.OPEN) &#123; //完全展开时并且点到主页面，拦截并关闭菜单 if (mMainContent.getLeft() &lt;= mRange &amp;&amp; ev.getRawX() &gt; mRange) &#123; return true; &#125; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = ev.getRawX(); break; case MotionEvent.ACTION_MOVE: //如果是向右滑，不拦截 float deltaX = ev.getRawX() - mDownX; if (deltaX &gt; 0) &#123; return false; &#125; break; &#125; &#125; return mDragHelper.shouldInterceptTouchEvent(ev);&#125; 列表控件列表里面其实只做了一个处理，就是判断上下滑动的时候就把事件拦截了： 12345678910111213141516171819@Overridepublic boolean onInterceptTouchEvent(MotionEvent e) &#123; switch (e.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = e.getRawX(); mDownY = e.getRawY(); break; case MotionEvent.ACTION_MOVE: //竖向滑动时拦截事件 float deltaX = e.getRawX() - mDownX; float deltaY = e.getRawY() - mDownY; if (deltaY != 0.0 &amp;&amp; Math.abs(deltaX / deltaY) &lt; 1) &#123; return true; &#125; break; &#125; return super.onInterceptTouchEvent(e);&#125; 删除控件这里什么都不用做，交给 ViewDragHelper 就好了： 123public boolean onInterceptTouchEvent(MotionEvent ev) &#123; return mDragHelper.shouldInterceptTouchEvent(ev);&#125; onTouchEventonTouchEvent 方法的返回值决定是否消费事件。 删除控件删除控件的 onTouchEvent 又有几个地方要做特殊处理的。当有展开的删除项时，点击别的删除项时就将展开的关闭。这样就可以了： 1234//存在已展开的控件且当前控件为关闭状态，则将所有展开控件关闭if (MainAdapter.mOpenItems.size() &gt; 0 &amp;&amp; mState == State.CLOSE) &#123; return false;&#125; 这里我没有消费事件，也没有进行关闭的操作，因为我把关闭的操作交给父控件去处理了，否则会有卡顿的现象（QQ 就有这个问题）。 如果点击的是展开的删除项左边区域，这个又比较特殊了。因为手指按下之后，有可能是滑动，也可能是点击。滑动的话是滑动删除项，点击则是将删除项关闭。所以我们要判断一下用户是否有滑动的操作: 12345678910111213141516171819switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = event.getRawX(); break; case MotionEvent.ACTION_MOVE: float deltaX = event.getRawX() - mDownX; if (Math.abs(deltaX) &gt; 50) &#123; isDrag = true; &#125; break; case MotionEvent.ACTION_UP: if (!isDrag &amp;&amp; event.getRawX() &lt;= mWidth - mBackWidth) &#123; close(); return true; &#125; isDrag = false; break;&#125; 当滑动距离大于 50 时，我就把它当做是一个滑动操作，这时候把滑动交给 ViewDragHelper 处理，否则就将当前控件关闭。 最后还有一个，当我滑动删除控件时，如果手指滑到了别的地方，滑动的依然是当前这个删除控件。换一个说法，其实就是一旦滑动了，父控件就不能再拦截我的滑动事件了。其实 ViewGroup 里面有一个 requestDisallowInterceptTouchEvent 方法，传 true 的时候，相当于通知它的所有父控件不要再拦截了。所以可以这样来处理： 1234567891011switch (event.getAction()) &#123; case MotionEvent.ACTION_MOVE: requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_CANCEL: requestDisallowInterceptTouchEvent(false); break; case MotionEvent.ACTION_UP: requestDisallowInterceptTouchEvent(false); break;&#125; 完整代码如下： 123456789101112131415161718192021222324252627282930313233343536public boolean onTouchEvent(MotionEvent event) &#123; //存在已展开的控件且当前控件为关闭状态，则将所有展开控件关闭 if (MainAdapter.mOpenItems.size() &gt; 0 &amp;&amp; mState == State.CLOSE) &#123; MainAdapter.closeAll(); return true; &#125; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: mDownX = event.getRawX(); break; case MotionEvent.ACTION_MOVE: requestDisallowInterceptTouchEvent(true); float deltaX = event.getRawX() - mDownX; if (Math.abs(deltaX) &gt; 50) &#123; isDrag = true; &#125; break; case MotionEvent.ACTION_CANCEL: requestDisallowInterceptTouchEvent(false); break; case MotionEvent.ACTION_UP: requestDisallowInterceptTouchEvent(false); if (!isDrag &amp;&amp; event.getRawX() &lt;= mWidth - mBackWidth) &#123; //展开状态下，点击左侧部分将其关闭 close(); return true; &#125; isDrag = false; break; &#125; mDragHelper.processTouchEvent(event); return true;&#125; 列表控件当有展开删除项且点击了别的删除项的时候，把关闭的操作继续往父控件抛就好了： 123public boolean onTouchEvent(MotionEvent e) &#123; return MainAdapter.mOpenItems.size() == 0 &amp;&amp; super.onTouchEvent(e);&#125; 菜单控件在这里处理一下上面说的那种情况： 12345678public boolean onTouchEvent(MotionEvent event) &#123; if (MainAdapter.mOpenItems.size() &gt; 0) &#123; MainAdapter.closeAll(); return true; &#125; mDragHelper.processTouchEvent(event); return true;&#125; 效果扯了这么多，看下效果吧： 搞半天其实也就这么样而已。 小结这篇有点啰嗦啊，里面涉及到的细节比较多。最后可能还会存在一些问题，这里主要是提供利用事件分发机制，处理手势冲突的思路。 写这个的时候发现 QQ 也有一些小问题，比如 QQ 在删除控件展开的情况下，按住删除控件左边区域下滑后，再左右滑，会出现列表跳动的问题。 大家可以点下面去看源码。就到这吧，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android Studio 2.3 正式版发布！看看有什么新功能]]></title>
      <url>%2F2017%2F03%2F04%2F201703041507%2F</url>
      <content type="text"><![CDATA[Android Studio 2.3 正式版发布了！来看看我们的劳动工具 2.3 有什么新功能吧！ 编译Instant Run工具栏上增加了一个“闪电”的标志，原来的 “Run” 按钮（Shift+F10）会保持全量编译。新增的“闪电”按钮（Gradle 需要升级到 2.3.0）才是 Instant Run，会在程序保持运行的情况下替换代码。 Instant Run 的底层代码有很大的改进，消除了的启动延时。 编译缓存使用编译缓存可以加快编译的速度。在 Android Studio 2.2 已经引进了编译缓存，但默认是关闭的。Android Studio 2.3 的编译缓存得到进一步优化，使用后的编译速度将会更快，而且是默认打开的。 设计约束布局（ConstraintLayout）Android Studio 2.3 包含了稳定版的 ConstraintLayout（意思是 2.2 里面的是不稳定版？！），现在可以将两个或以上的控件在一个维度上建立成一组，平铺在它们的父布局里。 支持按固定的比例缩放图片。 布局编辑器新的布局编辑器支持通过搜索、排序和过滤找到对应的控件，并且增加了一个预览的窗口。 布局属性收藏在布局的控件属性编辑窗口里面可以保存控件的属性，在对应属性左边点亮星号保存，被保存的属性将会出现在属性编辑窗口的 Favorites Attributes 栏下。 WebP图片格式在 Android Studio 2.3 里面支持将 PNG 格式的图片转换为 WebP 格式，WebP 格式的占用空间要比 PNG 格式小 25% 以上，并且是无损的。这将帮助减小 APK 的大小。要转换，只需右键 PNG 格式图片，点击 PNG file to convert to WebP 就可以了，也支持将 WebP 格式的图片恢复到 PNG 格式。 Material图标向导新的 Material 图标向导支持搜索和过滤。 开发Lint BaselineLint 是 Android Stuido 里面一个检查代码的功能，它可以查出不规范的代码、多余的资源、可能存在的bug等问题。可以通过 Analyze → Inspect Code 启用。 现在 Android Stuido 2.3 给它增加了一个小功能，可以将没有解决的Lint警告作为 Baseline，Baseline 只会显示新的警告。如果项目里面有很多的 Lint 警告，但是你只想去处理新的警告，就可以用上这个功能。 App 链接使用新的 App 链接助手可以很方便地创建 url 意图过滤器，并且支持测试。通过 Tools → App Link Assistant 打开 App 链接助手。 模板在模板里面，原来使用了 RelativeLayout 的布局现在替换成了 ConstraintLayout。 增加了一个带有底部导航栏的模板，遵循了材料设计的底部导航设计规范。 调试模拟器模拟器里面增加了 Pixel 和 Pixel XL。 模拟器支持和主机操作系统共享粘贴板，也就是可以互相复制粘贴了。需要使用 x86 Google API，并且 API 19（Android 4.4）以上的模拟器。 小结Android Stuido 2.3 带来的改进还是挺多的。 首先，编译速度又快了一些，我把关掉的 Instant Run 又打开了（咦？我为什么要说又）。 作为习惯写xm代码的码农来说，估计还没怎么用过 ConstraintLayout。谷歌从 16 年开发者大会之后就一直在推 ConstraintLayout，这次连默认模板里面的布局都改成了 ConstraintLayout 了，感觉是时候要了解一下了。 关于 WebP 格式，官方说可以减少 25% 以上的容量。我随便找了一张图片转，居然只有原来 5% 的大小。如果项目里面用到的图片比较多，可以在很大程度上减小 apk 的大小。 说实话，之前没怎么用过 Lint 检查代码。一旦用上了，作为一名不允许有一根黄线存在的强迫症患者，感觉又多了一些工作量。 就到这吧。妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用 Scalpel 3D 展示界面布局]]></title>
      <url>%2F2017%2F02%2F25%2F201702251837%2F</url>
      <content type="text"><![CDATA[无意中了解到 iOS 开发里面有一个叫 Reveal 的神器，用于 UI 调试。要是俺们安卓也能实现类似效果就好了。 Reveal 看上去是这个样子的： 很酷炫有木有！ 什么？Jake Wharton 大神早在几年前就给我们准备了类似的开源库了！ 今天要介绍的就是大神的 Scalpel，可以实现在手机上 3D 展示届满布局，而且用起来超级简单！ 在 Gradle 中引入 Scalpel： 1compile &apos;com.jakewharton.scalpel:scalpel:1.1.2&apos; 然后我们来到需要展示效果的布局文件，将它的根布局修改为 ScalpelFrameLayout，看名字也能猜到它是继承 FrameLayout 的。（要是去看源码你会发现，其实整个库只有 ScalpelFrameLayout这一个文件，四百多行代码，膜拜大神！） 然后在代码里面将 setContentView 修改成以下代码： 123456789View mainView = getLayoutInflater().inflate(R.layout.activity_main, null);ScalpelFrameLayout mScalpelFrameLayout = new ScalpelFrameLayout(this);mScalpelFrameLayout.addView(mainView);mScalpelFrameLayout.setLayerInteractionEnabled(true); //开启3D效果//mScalpelFrameLayout.setDrawIds(true); //是否显示控件id//mScalpelFrameLayout.setDrawViews(false); //是否展示控件内容，默认为true//mScalpelFrameLayout.setChromeColor(Color.RED); //修改边框颜色//mScalpelFrameLayout.setChromeShadowColor(Color.YELLOW); //修改阴影颜色setContentView(mScalpelFrameLayout); 跑一下看看效果： 妥妥的。 你问我有什么用？酷炫啊！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给 RecyclerView 加上折叠的效果]]></title>
      <url>%2F2017%2F02%2F18%2F201702181254%2F</url>
      <content type="text"><![CDATA[RecyclerView有很高的自由度，可以说只有想不到没有做不到，真是越用越喜欢。这次用超简单的方法，让 RecyclerView 带上折叠的效果。 效果是这样的。 总结一下这个列表的特点，就是以下三点： 重叠效果； 层次感； 首项的差动。 下面我们来一个个解决。 我们新建一个 ParallaxRecyclerView，让它继承 RecyclerView，并使用LinearLayoutManager作为布局管理器。 重叠效果其实就是每一项都搭一部分在它前面那项而已。我们知道，RecyclerView 可以通过设置 ItemDecoration 来实现列表的间隔效果，有没有想过要是把间隔设为负数会怎么样？比如： 1234567addItemDecoration(new ItemDecoration() &#123; @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, State state) &#123; super.getItemOffsets(outRect, view, parent, state); outRect.bottom = -dp2px(context, 10); &#125; &#125;); 没错，这就实现了我们的重叠效果。 层次感在 Material Design 里是有Z轴这个概念的，我们可以给控件设置垂直于屏幕的高度，让不在同一高度的控件看起来有层次感。当然，我们要用 Material Design 的控件才有这个属性，这里我用的是 CardView。 我们给 ParallaxRecyclerView 增加一个滑动监听，在 onScrolled 方法里面做如下设置： 12345678910111213141516LinearLayoutManager layoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();int firstPosition = layoutManager.findFirstVisibleItemPosition();int lastPosition = layoutManager.findLastVisibleItemPosition();int visibleCount = lastPosition - firstPosition;//重置控件的高度int elevation = 1;for (int i = firstPosition - 1; i &lt;= (firstPosition + visibleCount) + 1; i++) &#123; View view = layoutManager.findViewByPosition(i); if (view != null) &#123; if (view instanceof CardView) &#123; ((CardView) view).setCardElevation(dp2px(context, elevation)); elevation += 5; &#125; &#125;&#125; 其中，setCardElevation 方法就是用来给 CardView 设置高度的，这里让每一项的高度比它的上一项高 5dp。 首项的差动最后，我们想给第一项增加一个差动效果，这个同样在 onScrolled 方法里面做处理就好了： 123View firstView = layoutManager.findViewByPosition(firstPosition);float firstViewTop = firstView.getTop();firstView.setTranslationY(-firstViewTop / 2.0f); 这样相当于第一项的滑动速度变成原来的一半。但这也会导致一个问题， 由于改变了控件的位置，当这个控件被复用时，会出现位置不正确的情况。所以我们在设置高度的时候，可以顺便把控件的位置复原了： 1234 float translationY = view.getTranslationY();if (i &gt; firstPosition &amp;&amp; translationY != 0) &#123; view.setTranslationY(0);&#125; 这样就完成了一个带有简单折叠效果的 RecyclerView 了，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单实现带节点的进度条]]></title>
      <url>%2F2017%2F02%2F05%2F201702051620%2F</url>
      <content type="text"><![CDATA[带节点进度条的实现方法不止一个，但是如果要实现图中这种效果的，初步看好像还不简单。进度条的形状不规则、背景是渐变颜色、节点上面还有个勾。这里提供一个很简单的思路，简单的都不好意思说了…… 为了实现这个效果，我们需要三张图片，就是下面这三张。 看到这里可能你已经知道要怎么做了，三张图片分别是： 1.进度条填充部分的背景，带渐变颜色带节点小勾2.进度条未填充部分的背景，纯色3.进度条外框背景，是一张镂空图，颜色和进度条外的颜色一致 注意这三张图片的大小必须一致，将这三张图片叠加到一起就是我们的进度条了。至于进度条的动画，我们只要对第二层的那张图片实现一个属性动画就可以了： 12345678public void setProgress(float stage) &#123; int progressWidth = ivProgress.getWidth(); ObjectAnimator animator = ObjectAnimator.ofFloat(ivProgress, "translationX", stage * progressWidth); animator.setDuration((int) (Math.abs(stage - currentStage) * 1000)); animator.start(); currentStage = stage;&#125; 至于如何控制到哪一个节点，这个可以自己拿尺子量一下，多试几次，上面代码中的 stage 就是这个作用，它从这里取值： 12345678//不同阶段进度条所在位置public static final float STAGE0 = 0f;public static final float STAGE1 = 0.046f;public static final float STAGE2 = 0.285f;public static final float STAGE3 = 0.523f;public static final float STAGE4 = 0.761f;public static final float STAGE5 = 1f; 最后看一下效果。 这样就已经实现了一个看上去有点复杂的进度条了，妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[避免重复吐司( Toast )时，显示时间过长]]></title>
      <url>%2F2017%2F01%2F08%2F201701081106%2F</url>
      <content type="text"><![CDATA[当短时间内多次调用 Toast.makeText 方法时，会出现吐司显示的内容显示时间过长，或者当前吐司没有显示最新内容的情况。 这是因为吐司会像排队一样，每一个吐司都会有自己固定的时间（短吐司为 2 秒，长吐司为 3.5 秒），新的吐司需要在前面的吐司显示结束之后才会出现。解决这种情况也很简单。 在公共的工具类里面，增加这样一个方法来弹吐司： 123456789101112131415public void showToast(Context context, String text, boolean isLongLength) &#123; int length; if (isLongLength) &#123; length = Toast.LENGTH_LONG; &#125; else &#123; length = Toast.LENGTH_SHORT; &#125; if (toast == null) &#123; toast = Toast.makeText(context, text, length); &#125; else &#123; toast.setText(text); toast.setDuration(length); &#125; toast.show();&#125; 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[给 Android 图表库 MPAndroidChart 的坐标换行]]></title>
      <url>%2F2016%2F12%2F13%2F201612132202%2F</url>
      <content type="text"><![CDATA[做统计图时，经常会有这样的需求：x 坐标需要换行显示，日和月或者是月和年需要分两行显示。但是找遍 MPAndroidChart 的各种教程，好像也没有相关的方法可以实现…… 首先，MPAndroidChart 确实是没有提供更改坐标换行显示的方法。在看这篇文章之前，你可能已经尝试过实现一个 ValueFormatter，或者是 “\r\n” 这样的挣扎，发现并没有什么卵用。但就算真给你换行了，如何居中，如何设置两行不同字体也是问题。 咋办？看一下源码吧。看看设进去的数据是如何显示出来的。 以 LineChart 为例，我们是这样来设置坐标轴要显示的内容的： 123LineData data = new LineData(xValues, dataSets);mChart.setData(data);mChart.invalidate(); 跟着 setData 方法进源码，一路经过 Chart，BarLineChartBase，最终来到了 XAxisRenderer 这个类，我们的 xValues 被赋值给了它的 mXAxis。然后，好像就没有然后了…… 不对，别忘了我们 setData 之后还调用了 invalidate 方法请求重绘，重绘会去调用 Chart 的 onDraw 方法。再看看继承 Chart 的 BarLineChartBase，它的 onDraw 方法里出现了这一句: 1this.mXAxisRenderer.renderGridLines(canvas); 感觉离真相越来越近了。我们再跟着这个方法进来，看到里面调用了 drawLabels 方法，然后 drawLabels 又调用了 drawLabel 方法，最终我们来到了这里： 1234protected void drawLabel(Canvas c, String label, int xIndex, float x, float y, PointF anchor,float angleDegrees) &#123; String formattedLabel = mXAxis.getValueFormatter().getXValue(label, xIndex,mViewPortHandler); Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees);&#125; 最后进入 Utils.drawXAxisValue 方法，终于看到了这样的一句： 1c.drawText(text, drawOffsetX, drawOffsetY, paint); 哎呦我去，终于找到了，藏这么深。 可以看到坐标轴是用 Canvas.drawText 显示出来的。了解一下你会发现，通常情况下， drawText 方法是不支持 “\n\r” 的。看来我们只要改 drawLabel 这个方法就可以了。由于源码几个类的耦合程度比较高，我并没有找到可以通过继承重写的方法实现，不得已只好改源代码了。 我修改后的代码是这样的： 1234567891011121314151617181920212223242526protected void drawLabel(Canvas c, String label, int xIndex, float x, float y, PointF anchor, float angleDegrees) &#123; String formattedLabel = mXAxis.getValueFormatter().getXValue(label, xIndex, mViewPortHandler); float labelHeight = mXAxis.getTextSize(); float labelInterval = 25f; String[] labels = label.split(" "); Paint mFirstLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mFirstLinePaint.setColor(Color.WHITE); mFirstLinePaint.setTextAlign(Align.CENTER); mFirstLinePaint.setTextSize(Utils.convertDpToPixel(15f)); mFirstLinePaint.setTypeface(mXAxis.getTypeface()); Paint mSecondLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mSecondLinePaint.setColor(0xFF9b9b9b); mSecondLinePaint.setTextAlign(Align.CENTER); mSecondLinePaint.setTextSize(Utils.convertDpToPixel(10f)); mSecondLinePaint.setTypeface(mXAxis.getTypeface()); if (labels.length &gt; 1) &#123; Utils.drawXAxisValue(c, labels[0], x, y, mFirstLinePaint, anchor, angleDegrees); Utils.drawXAxisValue(c, labels[1], x, y + labelHeight + labelInterval, mSecondLinePaint, anchor, angleDegrees); &#125; else &#123; Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees); &#125;&#125; 我在要分行显示的字符串间加了个空格，在这里再用空格切割成两个字符串。我们可以分别给两行设置不同的格式，并且让他们都居中显示。最后绘制的时候，把第二行的 y 坐标改一下，在第一行的基础上加上一定的高度就可以了。妥妥的。 另外，那条黄色的高亮线也是改源码实现的。 2017.2.19 更新 MPAndroidChart 3.0 之后改变比较大，和这里相关的主要有两点： 取消了 LineData(List xVals, List dataSets) 这个构造方法，不再传x轴坐标数据，直接从 LineDataSet 坐标中获取。 MPAndroidChart 底层绘制X轴坐标，是先格式化之后才执行 drawLabel 这个方法。 处理的思路跟之前是一致的，可以用 ValueFormatter 格式化一下X轴的数据（比如用空格将要分行显示的数据分开），然后修改源码 XAxisRenderer 里面的 drawLabel，类似下面这样： 123456789101112131415161718192021222324protected void drawLabel(Canvas c, String formattedLabel, float x, float y, MPPointF anchor, float angleDegrees) &#123; float labelHeight = mXAxis.getTextSize(); float labelInterval = 25f; String[] labels = formattedLabel.split(" "); Paint mFirstLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mFirstLinePaint.setColor(Color.WHITE); mFirstLinePaint.setTextAlign(Align.CENTER); mFirstLinePaint.setTextSize(Utils.convertDpToPixel(15f)); mFirstLinePaint.setTypeface(mXAxis.getTypeface()); Paint mSecondLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mSecondLinePaint.setColor(0xFF9b9b9b); mSecondLinePaint.setTextAlign(Align.CENTER); mSecondLinePaint.setTextSize(Utils.convertDpToPixel(10f)); mSecondLinePaint.setTypeface(mXAxis.getTypeface()); if (labels.length &gt; 1) &#123; Utils.drawXAxisValue(c, labels[0], x, y, mFirstLinePaint, anchor, angleDegrees); Utils.drawXAxisValue(c, labels[1], x, y + labelHeight + labelInterval, mSecondLinePaint, anchor, angleDegrees); &#125; else &#123; Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees); &#125;&#125; 妥妥的。 2017.3.17 更新 补充一下高亮线的修改方法吧。 如果用的是不规则的高亮线（像图片里面上下有个球的），需要用自己的图片资源来替换。为了适配，建议使用高度可以拉伸的点九图。 我们先找到接口 ILineScatterCandleRadarDataSet，增加一个获取 Bitmap 的方法： 1234/** * @return 获取高亮线图片 bitmap */Bitmap getHighLightBitmap(); 再找到 LineScatterCandleRadarDataSet，增加这两个方法： 1234567891011121314151617protected Bitmap mHighlightBitmap = null;/** * 设置高亮线图片 * * @param bitmap 高亮线图片 bitmap */public void setHighlightBitmap(Bitmap bitmap) &#123; this.mHighlightBitmap = bitmap;&#125;/** * @return 获取高亮线图片 bitmap */public Bitmap getHighLightBitmap() &#123; return this.mHighlightBitmap;&#125; 最后找到设置高亮线的地方，它在 LineScatterCandleRadarRenderer 的 drawHighlightLines 方法里，可以把它修改成这个样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Draws vertical &amp; horizontal highlight-lines if enabled. * * @param c * @param x x-position of the highlight line intersection * @param y y-position of the highlight line intersection * @param set the currently drawn dataset */protected void drawHighlightLines(Canvas c, float x, float y, ILineScatterCandleRadarDataSet set) &#123; // set color and stroke-width mHighlightPaint.setColor(set.getHighLightColor()); mHighlightPaint.setStrokeWidth(set.getHighlightLineWidth()); // draw highlighted lines (if enabled) mHighlightPaint.setPathEffect(set.getDashPathEffectHighlight()); //优先使用高亮线图片显示，没有则使用默认样式 if (set.getHighLightBitmap() != null) &#123; if (set.isVerticalHighlightIndicatorEnabled()) &#123; Bitmap highLightBitmap = set.getHighLightBitmap(); NinePatch ninePatch = new NinePatch(highLightBitmap, highLightBitmap.getNinePatchChunk(), null); int highLightWidth = (int) Utils.convertDpToPixel(8.0F); RectF rectF = new RectF(x - (float) (highLightWidth / 2), this.mViewPortHandler.contentTop(), x + (float) (highLightWidth / 2), this.mViewPortHandler.contentBottom()); ninePatch.draw(c, rectF); &#125; &#125; else &#123; // draw vertical highlight lines if (set.isVerticalHighlightIndicatorEnabled()) &#123; // create vertical path mHighlightLinePath.reset(); mHighlightLinePath.moveTo(x, mViewPortHandler.contentTop()); mHighlightLinePath.lineTo(x, mViewPortHandler.contentBottom()); c.drawPath(mHighlightLinePath, mHighlightPaint); &#125; // draw horizontal highlight lines if (set.isHorizontalHighlightIndicatorEnabled()) &#123; // create horizontal path mHighlightLinePath.reset(); mHighlightLinePath.moveTo(mViewPortHandler.contentLeft(), y); mHighlightLinePath.lineTo(mViewPortHandler.contentRight(), y); c.drawPath(mHighlightLinePath, mHighlightPaint); &#125; &#125;&#125; 上面代码基于目前最新的 MPAndroidChart 3.0.1 ，旧版在细节上会有不同，但实现思路是一致的。 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现列表悬浮标签「顶上去」的效果]]></title>
      <url>%2F2016%2F11%2F27%2F201611272038%2F</url>
      <content type="text"><![CDATA[列表顶部的标签悬浮大家应该都知道，但「顶上去」是个啥玩意？ 看一下效果图就知道了，注意看顶部的悬浮标签切换时的效果： 这是我在之前一个自定义侧边索引栏的项目上修改的，对侧边索引栏的实现有兴趣的可以看一下之前的文章：自定义侧边快速索引栏 思路是这样子的： 布局里面增加一个和索引item长的一样的view，默认显示列表第一项的索引字母。 监听列表的滑动，当列表可见的第二项是索引item时，计算并更新悬浮view的Y坐标，让它处于索引item的上方。 监听列表的滑动，当列表可见第一项发生变化时，更新悬浮view显示的字母为当前可见第一项的索引字母。 感觉比想象中简单啊。可以看出逻辑都是在滑动事件里，我们用RecyclerView的addOnScrollListener方法监听列表的滑动事件，在监听器里面实现上面的逻辑。说的可能不是很好，看代码就知道多简单了。 监听器的代码如下： 12345678910111213141516171819202122232425262728293031323334353637class mScrollListener extends RecyclerView.OnScrollListener &#123; private int mFlowHeight; private int mCurrentPosition = -1; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; mFlowHeight = vFlow.getMeasuredHeight(); &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; int firstVisibleItemPosition = layoutManager.findFirstVisibleItemPosition(); View view = layoutManager.findViewByPosition(firstVisibleItemPosition + 1); if (view != null) &#123; if (view.getTop() &lt;= mFlowHeight &amp;&amp; isItem(firstVisibleItemPosition + 1)) &#123; vFlow.setY(view.getTop() - mFlowHeight); &#125; else &#123; vFlow.setY(0); &#125; &#125; if (mCurrentPosition != firstVisibleItemPosition) &#123; mCurrentPosition = firstVisibleItemPosition; tvFlowIndex.setText(mList.get(mCurrentPosition).getFirstWord()); &#125; &#125; /** * @param position 对应项的下标 * @return 是否为标签项 */ private boolean isItem(int position) &#123; return mAdapter.getItemViewType(position) == MainAdapter.VIEW_INDEX; &#125;&#125; 这样就已经实现「顶上去」的效果了，妥妥的。 最后说明一下，这个代码是使用 RecyclerView 实现的，要是用 ListView 的话是有问题的。ListView的item 使用 getTop() 方法，刚开始拿到的应该是 item 距离整个 ListView 最顶部的距离，要都是这样还好处理，但是复用item的时候这个值又发生了变化。总之就是，在使用 ListView 的时候，我还没有好的实现方法。要是哪位知道怎么实现，希望可以留言分享一下，不胜感激！ 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现一个带浮动标签的输入框]]></title>
      <url>%2F2016%2F11%2F27%2F201611271321%2F</url>
      <content type="text"><![CDATA[现在带浮动标签的输入框也是一个很常见的东西了，在材料设计里面有一个 TextInputLayout 的控件，我们可以用它实现这个效果。但是材料设计控件的样式比较固定，并不能满足我们产品设计的脑洞。这里提供一个用属性动画实现的方法。 还是先看看效果吧： 大概的思路是这样的： 控件有两层，一层是浮动的标签，一层是输入框。 当点击控件后，标签同时执行一个横向和纵向的缩放动画，还有一个向上移动的动画，让输入框获取到焦点并弹出键盘。 当输入框失去焦点时，判断是否有内容，如果没有则让标签执行一个复原的动画。 下面看看控件的布局： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/fl_content" android:layout_width="match_parent" android:layout_height="55dp" android:background="@color/white" android:orientation="vertical" android:paddingLeft="20dp"&gt; &lt;EditText android:id="@+id/et_content_name" android:layout_width="match_parent" android:layout_height="30dp" android:layout_gravity="center_vertical" android:background="@color/white" android:textColor="@color/black" android:textCursorDrawable="@null" android:textSize="14sp" android:visibility="gone" /&gt; &lt;TextView android:id="@+id/tv_content_hint" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:text="标题" android:textColor="@color/text_gray" android:textSize="14sp" android:transformPivotX="0dp" android:transformPivotY="-30dp" /&gt;&lt;/FrameLayout&gt; 由于 EditText 会默认获取到焦点，所以我先把它隐藏了。这里面值得注意的是 transformPivotXY 这个参数，等下会讲到。 然后我们创建标签向上缩放的方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435public void animationUp() &#123; ObjectAnimator scaleX = ObjectAnimator.ofFloat(tvHint, "scaleX", 0.6f); ObjectAnimator scaleY = ObjectAnimator.ofFloat(tvHint, "scaleY", 0.6f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(100); animatorSet.setInterpolator(new DecelerateInterpolator()); animatorSet.play(scaleX).with(scaleY); //两个动画同时开始 animatorSet.start(); animatorSet.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; etContent.setVisibility(View.VISIBLE); etContent.requestFocus(); //弹出键盘 InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(etContent, 0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;);&#125; 代码不难理解，就是同时执行了横向和纵向的缩放动画，让标签缩小到 60%。动画执行完后显示 EditText，让它获取到焦点并弹出键盘。如果 animatorSet.setInterpolator(new DecelerateInterpolator()); 这句不懂的话，看看下面这张图就明白了： 到这里，你可能还有的一个疑问就是，向上移动的动画呢？缩放动画是根据控件的基准坐标来进行缩放的。也就是说，当我们把基准坐标设在控件上方时，缩放的时候也会有一个移动的效果。所以在布局里面用 12android:transformPivotX=&quot;0dp&quot;android:transformPivotY=&quot;-30dp&quot; 将标签的基准点设为(0dp, -30dp)，这样我们就省去了移动动画。 至于复原的动画，就更简单了： 123456789101112public void animationDown() &#123; etContent.setVisibility(View.GONE); ObjectAnimator scaleX = ObjectAnimator.ofFloat(tvHint, "scaleX", 1); ObjectAnimator scaleY = ObjectAnimator.ofFloat(tvHint, "scaleY", 1); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(100); animatorSet.setInterpolator(new DecelerateInterpolator()); animatorSet.play(scaleX).with(scaleY); //两个动画同时开始 animatorSet.start();&#125; 为了实现失去焦点，标签复原，我们需要监听输入框是否有焦点： 12345678etContent.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View view, boolean b) &#123; if (!b &amp;&amp; TextUtils.isEmpty(etContent.getText())) &#123; animationDown(); &#125; &#125;&#125;); 这样就已经完成了一个带浮动标签的输入框，妥妥的。 虽然实现一个这样的控件不难，但我个人还是希望可以使用原生控件的，希望移动端的设计能多去了解一下材料设计吧。(T_T)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决用 drawBitmap 绘制点九图时，点九图不生效的问题]]></title>
      <url>%2F2016%2F11%2F21%2F201611212239%2F</url>
      <content type="text"><![CDATA[我们都知道点九图的作用，这里就不多说了，反正就是各种好各种美如画，这次我们把点九图用到自定义控件中。我们用 drawBitmap 来绘制点九图，然而似乎有点问题。 我找了这张图来演示一下： 这是用 drawBitmap 的代码： 123Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bubble);Rect rect = new Rect(l, t, r, b);canvas.drawBitmap(bitmap, null, rect, new Paint()); 然后编译运行。 哎呦，我去！这是什么鬼！说好的美如画呢。 没事，我们换两句代码来实现。当绘制点九图时，我们要用到 NinePatch 这个类，代码改成这样： 1234Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bubble);NinePatch ninePatch = new NinePatch(bitmap, bitmap.getNinePatchChunk(), null);RectF rectF = new RectF(l, t, r, b);ninePatch.draw(canvas, rectF); 再运行一次 看，妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义侧边快速索引栏]]></title>
      <url>%2F2016%2F11%2F20%2F201611201107%2F</url>
      <content type="text"><![CDATA[介绍现在有通讯录的项目基本都会用到侧边快速索引栏，网上也有不少第三方开源控件可以使用。但我讲的这个还是稍稍有点不一样的。 和一般索引栏不太一样的地方： 只显示有出现的首字母 出现的索引字母居中显示 代码相对较简单 好吧，编不下去了，其实也没什么不一样的，可以看一下效果图。 思路大致的实现过程如下： 获取要显示的字母 获取需要用到的宽高数值 绘制各个字母 处理 Touch 事件 还是挺简单的，稍稍有点难度的地方应该在计算。 代码自定义控件的实现方法有很多，这里我是用继承 View 来实现的，下面看看具体怎么实现。 获取要显示的字母通过 set 方法获取到要显示的字母集合后,重绘控件：1234public void setIndexs(String[] indexs) &#123; this.indexs = indexs; invalidate();&#125; 获取需要用到的宽高数值绘制侧边栏的时候,我们需要用到以下几个参数来计算字母所在的坐标： 控件的总宽度 mWidth 每个字母可以分配到的高度 mCellHeight 第一个字母和控件顶部的距离 mMarginTop(用于居中显示) 每个字母本身的宽高 当控件的的宽高发生变化时，会执行 onSizeChanged 这个方法，在首次初始化时也会调用，所以前三个参数我们可以在这里获取到。这里考虑最多会出现 27 个字符，如果首字母是数字或者特殊字符，我们用「#」表示。mMarginTop 可能要理解一下，第一个字母距离控件顶部的距离，是控件总高度减去所有字母的总高度的一半，应该不是很难理解： 12345678@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); mCellHeight = (mHeight * 1f / 27); //26个字母加上“#” mMarginTop = (mHeight - mCellHeight * indexs.length) / 2;&#125; 但要说明一下的是，加载控件是需要时间的（处理过 SwipeRefreshLayout 一进去就要转圈的应该理解）。也就是说 onSizeChanged 可能在 setIndexs 之前执行，也可能在它之后执行。这就可能会导致获取不到 mMarginTop，所以我们在 setIndexs 里也加上 mMarginTop = (mHeight - mCellHeight * indexs.length) / 2 这句代码，保证可以拿到这个参数。 至于字母的宽高，不同字母的宽高其实都不一样的，我们可以通过以下方法获取到： 1234567891011public float getTextWidth(String text) &#123; Rect bounds = new Rect(); mPaint.getTextBounds(text, 0, text.length(), bounds); return bounds.width();&#125;public float getTextHeight(String text) &#123; Rect bounds = new Rect(); mPaint.getTextBounds(text, 0, text.length(), bounds); return bounds.height();&#125; 绘制各个字母通过上面获取到的参数，我们可以计算出每个字母的坐标。简单说明一下，使用drawText绘制时使用x坐标是字母最左边的坐标，而 y 坐标是指字母 baseline 的坐标。我们可以简单理解为是字母左下角的坐标。 x 坐标为了让字母在控件里左右居中显示，x 坐标就是控件总宽度的一半减去字母宽度的一半： 1float x = mWidth / 2 - getTextWidth(letter) / 2; y 坐标y 坐标的计算可能要理解一下。首先和宽度类似，让字母在它占有的空间里面上下居中，也就是字母占有高度的一半加上字母高度的一半。然后要加上它前面所有字母的高度，及首字母距离顶部的距离： 1float y = mCellHeight / 2 + getTextHeight(letter) / 2 + mCellHeight * i + mMarginTop; 所以 onDraw 的代码可以这样写： 123456789101112 @Overrideprotected void onDraw(Canvas canvas) &#123; if (indexs.length &lt;= 0) &#123; return; &#125; for (int i = 0; i &lt; indexs.length; i++) &#123; String letter = indexs[i]; float x = mWidth / 2 - getTextWidth(letter) / 2; float y = mCellHeight / 2 + getTextHeight(letter) / 2 + mCellHeight * i + mMarginTop; canvas.drawText(letter, x, y, mPaint); &#125;&#125; 处理Touch事件这个控件的点击和滑动事件做了相同的操作，通过计算当前按下字母的下标来获取到该字母，显示吐司，并且通过回调函数让列表定位。当手指抬起时，把吐司隐藏就好了。 12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 按下 case MotionEvent.ACTION_MOVE: // 滑动 // 按下字母的下标 int letterIndex = (int) ((event.getY() - mMarginTop) / mCellHeight); // 判断是否越界 if (letterIndex &gt;= 0 &amp;&amp; letterIndex &lt; indexs.length) &#123; // 显示按下的字母 if (textView != null) &#123; textView.setVisibility(View.VISIBLE); textView.setText(indexs[letterIndex]); &#125; //通过回调方法通知列表定位 if (mOnIndexChangedListener != null) &#123; mOnIndexChangedListener.onIndexChanged(indexs[letterIndex]); &#125; &#125; break; case MotionEvent.ACTION_UP: // 提起 if (textView != null) &#123; textView.setVisibility(View.GONE); &#125; break; &#125; return true;&#125; 到这里，自定义控件就算完成啦。接下来看看它是如何使用的。 使用现在布局里面使用我们的自定义控件，我是这样写的： 12345&lt;com.southernbox.indexbar.widget.IndexBar android:id="@+id/indexbar" android:layout_width="20dp" android:layout_height="match_parent" android:layout_alignParentRight="true" /&gt; 然后就是设置索引字母数组，设置要吐司的 TextView，设置回调方法。在 RecyclerView 中，我们可以使用 LayoutManager 来定位。 123456789101112131415mIndexBar.setIndexs(letters);mIndexBar.setSelectedIndexTextView(tvToast);mIndexBar.setOnIndexChangedListener(new IndexBar.OnIndexChangedListener() &#123; @Override public void onIndexChanged(String index) &#123; for (int i = 0; i &lt; mList.size(); i++) &#123; String firstword = mList.get(i).getFirstword(); if (index.equals(firstword)) &#123; // 滚动列表到指定的位置 layoutManager.scrollToPositionWithOffset(i, 0); return; &#125; &#125; &#125; &#125;); 最后，我们需要写一个方法用来排序，插入索引 item，顺便把要显示的索引字母数组获取到。在 item 的实体类里面，我用 isIndex 这个字段来区分是索引 item，还是普通 item。可以参考一下我的排序方法： 123456789101112131415161718192021222324252627282930313233public Map&lt;String, Object&gt; convertSortList(List&lt;Entity&gt; list) &#123; HashMap&lt;String, List&lt;Entity&gt;&gt; map = new HashMap&lt;&gt;(); for (Entity item : list) &#123; String firstWord; if (TextUtils.isEmpty(item.getFirstWord())) &#123; firstWord = "#"; &#125; else &#123; firstWord = item.getFirstWord().toUpperCase(); &#125; if (map.containsKey(firstWord)) &#123; map.get(firstWord).add(item); &#125; else &#123; List&lt;Entity&gt; mList = new ArrayList&lt;&gt;(); mList.add(item); map.put(firstWord, mList); &#125; &#125; Object[] keys = map.keySet().toArray(); Arrays.sort(keys); List&lt;Entity&gt; sortList = new ArrayList&lt;&gt;(); for (Object key : keys) &#123; Entity t = getIndexItem(key.toString()); sortList.add(t); sortList.addAll(map.get(key)); &#125; HashMap&lt;String, Object&gt; resultMap = new HashMap(); resultMap.put("sortList", sortList); resultMap.put("keys", keys); return resultMap;&#125; 还有一点要说明一下的是，一般情况下侧边索引栏的「#」是放在最后一个的，但是用 Arrays.sort 排序的话会把它放在第一个，要放最后一个的话还要再做一个转换，这里就不再赘述了。 结语这个控件还是比较简单的，这也是一个比较适合用来入门的控件，可能要理解一下的地方在计算方面。个人觉得，如果一个控件不是太复杂的话，最好是自己实现，或者至少要看明白源码。这样一方面可以修改控件适合自己的项目使用，一方面出现了 bug 也可以快速定位修改。妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 ScrollView 嵌套 RecyclerView 时，惯性滑动失效的问题]]></title>
      <url>%2F2016%2F11%2F13%2F201611130905%2F</url>
      <content type="text"><![CDATA[大家知道 ScrollView 是带有惯性滑动效果的。但是在 5.0 以上系统使用 ScrollView 嵌套 RecyleView 时，惯性滑动会失效，滑起来会感觉很不顺畅。那怎么解决呢？ 方法很简单，我们只要让 RecyleView 不可滑动就可以了。RecyleView 是否可左右、上下滑动，是由 LayoutManager 的 canScrollHorizontally 和 canScrollVertically 方法控制的，我们让相应的方法返回 false 就可以了。代码如下： 1234567LinearLayoutManager layoutManager = new LinearLayoutManager(mContext)&#123; @Override public boolean canScrollVertically() &#123; return false; &#125;&#125;;recyclerView.setLayoutManager(layoutManager); 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决 Volley 获取网络数据出现乱码]]></title>
      <url>%2F2016%2F11%2F12%2F201611122333%2F</url>
      <content type="text"><![CDATA[刚接触使用 Volley 的时候，发现 Volley 会出现 UTF-8 编码的中文字符串乱码的情况。这里给出一个解决方法。 以 StringRequest 请求为例，其它的类似写一个类继承 StringRequest，然后重写 Response parseNetworkResponse(NetworkResponse response) 方法，将编码指定为 utf-8，代码如下： 12345678910111213141516171819202122public class MyStringRequest extends StringRequest &#123; public MyStringRequest(String url, Response.Listener&lt;String&gt; listener, Response.ErrorListener errorListener) &#123; super(url, listener, errorListener); &#125; /** * 重写以解决乱码问题 */ @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String str = null; try &#123; str = new String(response.data, "utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return Response.success(str, HttpHeaderParser.parseCacheHeaders(response)); &#125;&#125; 使用的时候用我们继承过的 MyStringRequest 类，而不是 StringRequest，问题就解决了。妥妥的。]]></content>
    </entry>

    
  
  
</search>
