<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[给Android图表库MPAndroidChart的坐标换行]]></title>
      <url>%2F2016%2F12%2F13%2F201612132202%2F</url>
      <content type="text"><![CDATA[做统计图时，经常会有这样的需求：x坐标需要换行显示，日和月或者是月和年需要分两行显示。但是找遍MPAndroidChart的各种教程，好像也没有相关的方法可以实现…… 以LineChart为例，我们想要的效果是类似这样子的: 首先，MPAndroidChart确实是没有提供更改坐标换行显示的方法。在看这篇文章之前，你可能已经尝试过实现一个ValueFormatter，或者是”\r\n”这样的挣扎，发现并没有什么卵用。但就算真给你换行了，如何居中，如何设置两行不同字体也是问题。 咋办？看一下源码吧。看看设进去的数据是如何显示出来的。 我们是这样来设置坐标轴要显示的内容的： 123LineData data = new LineData(xValues, dataSets);mChart.setData(data);mChart.invalidate(); 跟着setData方法进源码，一路经过Chart，BarLineChartBase，最终来到了XAxisRenderer这个类，我们的xValues被赋值给了它的mXAxis。然后，好像就没有然后了…… 不对，别忘了我们setData之后还调用了invalidate方法请求重绘，重绘会去调用Chart的onDraw方法。再看看继承Chart的BarLineChartBase，它的onDraw方法里出现了这一句: 1this.mXAxisRenderer.renderGridLines(canvas); 感觉离真相越来越近了。我们再跟着这个方法进来，看到里面调用了drawLabels方法，然后drawLabels又调用了drawLabel方法，最终我们来到了这里： 1234protected void drawLabel(Canvas c, String label, int xIndex, float x, float y, PointF anchor,float angleDegrees) &#123; String formattedLabel = mXAxis.getValueFormatter().getXValue(label, xIndex,mViewPortHandler); Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees);&#125; 最后进入Utils.drawXAxisValue方法，终于看到了这样的一句： 1c.drawText(text, drawOffsetX, drawOffsetY, paint); 哎呦我去，终于找到了，藏这么深。 可以看到坐标轴是用Canvas.drawText显示出来的。了解一下你会发现，通常情况下，drawText方法是不支持”\n\r”的。看来我们只要改drawLabel这个方法就可以了。由于源码几个类的耦合程度比较高，我并没有找到可以通过继承重写的方法实现，不得已只好改源代码了。 我修改后的代码是这样的： 1234567891011121314151617181920212223242526protected void drawLabel(Canvas c, String label, int xIndex, float x, float y, PointF anchor, float angleDegrees) &#123; String formattedLabel = mXAxis.getValueFormatter().getXValue(label, xIndex, mViewPortHandler); float labelHeight = mXAxis.getTextSize(); float labelInterval = 25f; String[] labels = label.split(" "); Paint mFirstLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mFirstLinePaint.setColor(Color.WHITE); mFirstLinePaint.setTextAlign(Align.CENTER); mFirstLinePaint.setTextSize(Utils.convertDpToPixel(15f)); mFirstLinePaint.setTypeface(mXAxis.getTypeface()); Paint mSecondLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG); mSecondLinePaint.setColor(0xFF9b9b9b); mSecondLinePaint.setTextAlign(Align.CENTER); mSecondLinePaint.setTextSize(Utils.convertDpToPixel(10f)); mSecondLinePaint.setTypeface(mXAxis.getTypeface()); if (labels.length &gt; 1) &#123; Utils.drawXAxisValue(c, labels[0], x, y, mFirstLinePaint, anchor, angleDegrees); Utils.drawXAxisValue(c, labels[1], x, y + labelHeight + labelInterval, mSecondLinePaint, anchor, angleDegrees); &#125; else &#123; Utils.drawXAxisValue(c, formattedLabel, x, y, mFirstLinePaint, anchor, angleDegrees); &#125;&#125; 我在要分行显示的字符串间加了个空格，在这里再用空格切割成两个字符串。我们可以分别给两行设置不同的格式，并且让他们都居中显示。最后绘制的时候，把第二行的y坐标改一下，在第一行的基础上加上一定的高度就可以了。妥妥的。 另外，那条黄色的高亮线也是改源码实现的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现列表悬浮标签“顶上去”的效果]]></title>
      <url>%2F2016%2F11%2F27%2F201611272038%2F</url>
      <content type="text"><![CDATA[列表顶部的标签悬浮大家应该都知道，但“顶上去”是个啥玩意？ 看一下效果图就知道了，注意看顶部的悬浮标签切换时的效果： 这是我在之前一个自定义侧边索引栏的项目上修改的，对侧边索引栏的实现有兴趣的可以看一下之前的文章：自定义侧边快速索引栏 思路是这样子的： 布局里面增加一个和索引item长的一样的view，默认显示列表第一项的索引字母。 监听列表的滑动，当列表可见的第二项是索引item时，计算并更新悬浮view的Y坐标，让它处于索引item的上方。 监听列表的滑动，当列表可见第一项发生变化时，更新悬浮view显示的字母为当前可见第一项的索引字母。 感觉比想象中简单啊。可以看出逻辑都是在滑动事件里，我们用RecyclerView的addOnScrollListener方法监听列表的滑动事件，在监听器里面实现上面的逻辑。说的可能不是很好，看代码就知道多简单了。 监听器的代码如下： 12345678910111213141516171819202122232425262728293031323334353637class mScrollListener extends RecyclerView.OnScrollListener &#123; private int mFlowHeight; private int mCurrentPosition = -1; @Override public void onScrollStateChanged(RecyclerView recyclerView, int newState) &#123; mFlowHeight = vFlow.getMeasuredHeight(); &#125; @Override public void onScrolled(RecyclerView recyclerView, int dx, int dy) &#123; int firstVisibleItemPosition = layoutManager.findFirstVisibleItemPosition(); View view = layoutManager.findViewByPosition(firstVisibleItemPosition + 1); if (view != null) &#123; if (view.getTop() &lt;= mFlowHeight &amp;&amp; isItem(firstVisibleItemPosition + 1)) &#123; vFlow.setY(view.getTop() - mFlowHeight); &#125; else &#123; vFlow.setY(0); &#125; &#125; if (mCurrentPosition != firstVisibleItemPosition) &#123; mCurrentPosition = firstVisibleItemPosition; tvFlowIndex.setText(mList.get(mCurrentPosition).getFirstWord()); &#125; &#125; /** * @param position 对应项的下标 * @return 是否为标签项 */ private boolean isItem(int position) &#123; return mAdapter.getItemViewType(position) == MainAdapter.VIEW_INDEX; &#125;&#125; 这样就已经实现“顶上去的效果了”，妥妥的。 最后说明一下，这个代码是使用RecyclerView实现的，要是用ListView的话是有问题的。ListView的item使用getTop()方法，刚开始拿到的应该是item距离整个ListView最顶部的距离，要都是这样还好处理，但是复用item的时候这个值又发生了变化。总之就是，在使用ListView的时候，我还没有好的实现方法。要是哪位知道怎么实现，希望可以留言分享一下，不胜感激！ 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现一个带浮动标签的输入框]]></title>
      <url>%2F2016%2F11%2F27%2F201611271321%2F</url>
      <content type="text"><![CDATA[现在带浮动标签的输入框也是一个很常见的东西了，在材料设计里面有一个TextInputLayout的控件，我们可以用它实现这个效果。但是材料设计控件的样式比较固定，并不能满足我们产品设计的脑洞。这里提供一个用属性动画实现的方法。 还是先看看效果吧： 大概的思路是这样的： 控件有两层，一层是浮动的标签，一层是输入框。 当点击控件后，标签同时执行一个横向和纵向的缩放动画，还有一个向上移动的动画，让输入框获取到焦点并弹出键盘。 当输入框失去焦点时，判断是否有内容，如果没有则让标签执行一个复原的动画。 下面看看控件的布局： 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/fl_content" android:layout_width="match_parent" android:layout_height="55dp" android:background="@color/white" android:orientation="vertical" android:paddingLeft="20dp"&gt; &lt;EditText android:id="@+id/et_content_name" android:layout_width="match_parent" android:layout_height="30dp" android:layout_gravity="center_vertical" android:background="@color/white" android:textColor="@color/black" android:textCursorDrawable="@null" android:textSize="14sp" android:visibility="gone" /&gt; &lt;TextView android:id="@+id/tv_content_hint" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_gravity="center_vertical" android:text="标题" android:textColor="@color/text_gray" android:textSize="14sp" android:transformPivotX="0dp" android:transformPivotY="-30dp" /&gt;&lt;/FrameLayout&gt; 由于EditText会默认获取到焦点，所以我先把它隐藏了。这里面值得注意的是transformPivotXY这个参数，等下会讲到。 然后我们创建标签向上缩放的方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435public void animationUp() &#123; ObjectAnimator scaleX = ObjectAnimator.ofFloat(tvHint, "scaleX", 0.6f); ObjectAnimator scaleY = ObjectAnimator.ofFloat(tvHint, "scaleY", 0.6f); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(100); animatorSet.setInterpolator(new DecelerateInterpolator()); animatorSet.play(scaleX).with(scaleY); //两个动画同时开始 animatorSet.start(); animatorSet.addListener(new Animator.AnimatorListener() &#123; @Override public void onAnimationStart(Animator animation) &#123; &#125; @Override public void onAnimationEnd(Animator animation) &#123; etContent.setVisibility(View.VISIBLE); etContent.requestFocus(); //弹出键盘 InputMethodManager imm = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE); imm.showSoftInput(etContent, 0); &#125; @Override public void onAnimationCancel(Animator animation) &#123; &#125; @Override public void onAnimationRepeat(Animator animation) &#123; &#125; &#125;);&#125; 代码不难理解，就是同时执行了横向和纵向的缩放动画，让标签缩小到60%。动画执行完后显示EditText，让它获取到焦点并弹出键盘。如果animatorSet.setInterpolator(new DecelerateInterpolator());这句不懂的话，看看下面这张图就明白了： 到这里，你可能还有的一个疑问就是，向上移动的动画呢？缩放动画是根据控件的基准坐标来进行缩放的。也就是说，当我们把基准坐标设在控件上方时，缩放的时候也会有一个移动的效果。所以在布局里面用 12android:transformPivotX=&quot;0dp&quot;android:transformPivotY=&quot;-30dp&quot; 将标签的基准点设为(0dp, -30dp)，这样我们就省去了移动动画。 至于复原的动画，就更简单了： 123456789101112public void animationDown() &#123; etContent.setVisibility(View.GONE); ObjectAnimator scaleX = ObjectAnimator.ofFloat(tvHint, "scaleX", 1); ObjectAnimator scaleY = ObjectAnimator.ofFloat(tvHint, "scaleY", 1); AnimatorSet animatorSet = new AnimatorSet(); animatorSet.setDuration(100); animatorSet.setInterpolator(new DecelerateInterpolator()); animatorSet.play(scaleX).with(scaleY); //两个动画同时开始 animatorSet.start();&#125; 为了实现失去焦点，标签复原，我们需要监听输入框是否有焦点： 12345678etContent.setOnFocusChangeListener(new OnFocusChangeListener() &#123; @Override public void onFocusChange(View view, boolean b) &#123; if (!b &amp;&amp; TextUtils.isEmpty(etContent.getText())) &#123; animationDown(); &#125; &#125;&#125;); 这样就已经完成了一个带浮动标签的输入框，妥妥的。 虽然实现一个这样的控件不难，但我个人还是希望可以使用原生控件的，希望移动端的设计能多去了解一下材料设计吧。(T_T)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决用drawBitmap绘制点九图时，点九图不生效的问题]]></title>
      <url>%2F2016%2F11%2F21%2F201611212239%2F</url>
      <content type="text"><![CDATA[我们都知道点九图的作用，这里就不多说了，反正就是各种好各种美如画，这次我们把点九图用到自定义控件中。我们用drawBitmap来绘制点九图，然而似乎有点问题。 我找了这张图来演示一下：这是用drawBitmap的代码： 123Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bubble);Rect rect = new Rect(l, t, r, b);canvas.drawBitmap(bitmap, null, rect, new Paint()); 然后编译运行。 哎呦，我去！这是什么鬼！说好的美如画呢。 没事，我们换两句代码来实现。当绘制点九图时，我们要用到NinePatch这个类，代码改成这样： 1234Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bubble);NinePatch ninePatch = new NinePatch(bitmap, bitmap.getNinePatchChunk(), null);RectF rectF = new RectF(l, t, r, b);ninePatch.draw(canvas, rectF); 再运行一次 看，妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自定义侧边快速索引栏]]></title>
      <url>%2F2016%2F11%2F20%2F201611201107%2F</url>
      <content type="text"><![CDATA[介绍现在有通讯录的项目基本都会用到侧边快速索引栏，网上也有不少第三方开源控件可以使用。但我讲的这个还是稍稍有点不一样的。 和一般索引栏不太一样的地方： 只显示有出现的首字母 出现的索引字母居中显示 代码相对较简单 好吧，编不下去了，其实也没什么不一样的，可以看一下效果图。 思路大致的实现过程如下： 获取要显示的字母 获取需要用到的宽高数值 绘制各个字母 处理Touch事件 还是挺简单的，稍稍有点难度的地方应该在计算。 代码自定义控件的实现方法有很多，这里我是用继承View来实现的，下面看看具体怎么实现。 获取要显示的字母通过set方法获取到要显示的字母集合后,重绘控件：1234public void setIndexs(String[] indexs) &#123; this.indexs = indexs; invalidate();&#125; 获取需要用到的宽高数值绘制侧边栏的时候,我们需要用到以下几个参数来计算字母所在的坐标： 控件的总宽度mWidth 每个字母可以分配到的高度mCellHeight 第一个字母和控件顶部的距离mMarginTop(用于居中显示) 每个字母本身的宽高 当控件的的宽高发生变化时，会执行onSizeChanged这个方法，在首次初始化时也会调用，所以前三个参数我们可以在这里获取到。这里考虑最多会出现27个字符，如果首字母是数字或者特殊字符，我们用“#”表示。mMarginTop可能要理解一下，第一个字母距离控件顶部的距离，是控件总高度减去所有字母的总高度的一半，应该不是很难理解：12345678@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mWidth = getMeasuredWidth(); mHeight = getMeasuredHeight(); mCellHeight = (mHeight * 1f / 27); //26个字母加上“#” mMarginTop = (mHeight - mCellHeight * indexs.length) / 2;&#125; 但要说明一下的是，加载控件是需要时间的（处理过SwipeRefreshLayout一进去就要转圈的应该理解）。也就是说onSizeChanged可能在setIndexs之前执行，也可能在它之后执行。这就可能会导致获取不到mMarginTop，所以我们在setIndexs里也加上mMarginTop = (mHeight - mCellHeight * indexs.length) / 2这句代码，保证可以拿到这个参数。 至于字母的宽高，不同字母的宽高其实都不一样的，我们可以通过以下方法获取到：1234567891011public float getTextWidth(String text) &#123; Rect bounds = new Rect(); mPaint.getTextBounds(text, 0, text.length(), bounds); return bounds.width();&#125;public float getTextHeight(String text) &#123; Rect bounds = new Rect(); mPaint.getTextBounds(text, 0, text.length(), bounds); return bounds.height();&#125; 绘制各个字母通过上面获取到的参数，我们可以计算出每个字母的坐标。简单说明一下，使用drawText绘制时使用x坐标是字母最左边的坐标，而y坐标是指字母baseline的坐标。我们可以简单理解为是字母左下角的坐标。 X坐标为了让字母在控件里左右居中显示，x坐标就是控件总宽度的一半减去字母宽度的一半：1float x = mWidth / 2 - getTextWidth(letter) / 2; Y坐标y坐标的计算可能要理解一下。首先和宽度类似，让字母在它占有的空间里面上下居中，也就是字母占有高度的一半加上字母高度的一半。然后要加上它前面所有字母的高度，及首字母距离顶部的距离：1float y = mCellHeight / 2 + getTextHeight(letter) / 2 + mCellHeight * i + mMarginTop; 所以onDraw的代码可以这样写：123456789101112 @Overrideprotected void onDraw(Canvas canvas) &#123; if (indexs.length &lt;= 0) &#123; return; &#125; for (int i = 0; i &lt; indexs.length; i++) &#123; String letter = indexs[i]; float x = mWidth / 2 - getTextWidth(letter) / 2; float y = mCellHeight / 2 + getTextHeight(letter) / 2 + mCellHeight * i + mMarginTop; canvas.drawText(letter, x, y, mPaint); &#125;&#125; 处理Touch事件这个控件的点击和滑动事件做了相同的操作，通过计算当前按下字母的下标来获取到该字母，显示吐司，并且通过回调函数让列表定位。当手指抬起时，把吐司隐藏就好了。12345678910111213141516171819202122232425262728@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: // 按下 case MotionEvent.ACTION_MOVE: // 滑动 // 按下字母的下标 int letterIndex = (int) ((event.getY() - mMarginTop) / mCellHeight); // 判断是否越界 if (letterIndex &gt;= 0 &amp;&amp; letterIndex &lt; indexs.length) &#123; // 显示按下的字母 if (textView != null) &#123; textView.setVisibility(View.VISIBLE); textView.setText(indexs[letterIndex]); &#125; //通过回调方法通知列表定位 if (mOnIndexChangedListener != null) &#123; mOnIndexChangedListener.onIndexChanged(indexs[letterIndex]); &#125; &#125; break; case MotionEvent.ACTION_UP: // 提起 if (textView != null) &#123; textView.setVisibility(View.GONE); &#125; break; &#125; return true;&#125; 到这里，自定义控件就算完成啦。接下来看看它是如何使用的。 使用现在布局里面使用我们的自定义控件，我是这样写的：12345&lt;com.southernbox.indexbar.widget.IndexBar android:id="@+id/indexbar" android:layout_width="20dp" android:layout_height="match_parent" android:layout_alignParentRight="true" /&gt; 然后就是设置索引字母数组，设置要吐司的TextView，设置回调方法。在RecyclerView中，我们可以使用LayoutManager来定位。123456789101112131415mIndexBar.setIndexs(letters);mIndexBar.setSelectedIndexTextView(tvToast);mIndexBar.setOnIndexChangedListener(new IndexBar.OnIndexChangedListener() &#123; @Override public void onIndexChanged(String index) &#123; for (int i = 0; i &lt; mList.size(); i++) &#123; String firstword = mList.get(i).getFirstword(); if (index.equals(firstword)) &#123; // 滚动列表到指定的位置 layoutManager.scrollToPositionWithOffset(i, 0); return; &#125; &#125; &#125; &#125;); 最后，我们需要写一个方法用来排序，插入索引item，顺便把要显示的索引字母数组获取到。在item的实体类里面，我用isIndex这个字段来区分是索引item，还是普通item。可以参考一下我的排序方法：123456789101112131415161718192021222324252627282930313233public Map&lt;String, Object&gt; convertSortList(List&lt;Entity&gt; list) &#123; HashMap&lt;String, List&lt;Entity&gt;&gt; map = new HashMap&lt;&gt;(); for (Entity item : list) &#123; String firstWord; if (TextUtils.isEmpty(item.getFirstWord())) &#123; firstWord = "#"; &#125; else &#123; firstWord = item.getFirstWord().toUpperCase(); &#125; if (map.containsKey(firstWord)) &#123; map.get(firstWord).add(item); &#125; else &#123; List&lt;Entity&gt; mList = new ArrayList&lt;&gt;(); mList.add(item); map.put(firstWord, mList); &#125; &#125; Object[] keys = map.keySet().toArray(); Arrays.sort(keys); List&lt;Entity&gt; sortList = new ArrayList&lt;&gt;(); for (Object key : keys) &#123; Entity t = getIndexItem(key.toString()); sortList.add(t); sortList.addAll(map.get(key)); &#125; HashMap&lt;String, Object&gt; resultMap = new HashMap(); resultMap.put("sortList", sortList); resultMap.put("keys", keys); return resultMap;&#125; 还有一点要说明一下的是，一般情况下侧边索引栏的”#”是放在最后一个的，但是用Arrays.sort排序的话会把它放在第一个，要放最后一个的话还要再做一个转换，这里就不再赘述了。 结语这个控件还是比较简单的，这也是一个比较适合用来入门的控件，可能要理解一下的地方在计算方面。个人觉得，如果一个控件不是太复杂的话，最好是自己实现，或者至少要看明白源码。这样一方面可以修改控件适合自己的项目使用，一方面出现了bug也可以快速定位修改。妥妥的。 源码地址]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决ScrollView嵌套RecyclerView时，惯性滑动失效的问题]]></title>
      <url>%2F2016%2F11%2F13%2F201611130905%2F</url>
      <content type="text"><![CDATA[大家知道ScrollView是带有惯性滑动效果的。但是在5.0以上系统使用ScrollView嵌套RecyleView时，惯性滑动会失效，滑起来会感觉很不顺畅。那怎么解决呢？ 方法很简单，我们只要让RecyleView不可滑动就可以了。RecyleView是否可左右、上下滑动，是由LayoutManager的canScrollHorizontally和canScrollVertically方法控制的，我们让相应的方法返回false就可以了。代码如下： 1234567LinearLayoutManager layoutManager = new LinearLayoutManager(mContext)&#123; @Override public boolean canScrollVertically() &#123; return false; &#125;&#125;;recyclerView.setLayoutManager(layoutManager); 妥妥的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[解决Volley获取网络数据出现乱码]]></title>
      <url>%2F2016%2F11%2F12%2F201611122333%2F</url>
      <content type="text"><![CDATA[刚接触使用Volley的时候，发现Volley会出现UTF-8编码的中文字符串乱码的情况。这里给出一个解决方法。 以StringRequest请求为例，其它的类似写一个类继承StringRequest，然后重写Response parseNetworkResponse(NetworkResponse response)方法，将编码指定为utf-8，代码如下： 12345678910111213141516171819202122public class MyStringRequest extends StringRequest &#123; public MyStringRequest(String url, Response.Listener&lt;String&gt; listener, Response.ErrorListener errorListener) &#123; super(url, listener, errorListener); &#125; /** * 重写以解决乱码问题 */ @Override protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String str = null; try &#123; str = new String(response.data, "utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; return Response.success(str, HttpHeaderParser.parseCacheHeaders(response)); &#125;&#125; 使用的时候用我们继承过的MyStringRequest类，而不是StringRequest，问题就解决了。妥妥的。]]></content>
    </entry>

    
  
  
</search>
